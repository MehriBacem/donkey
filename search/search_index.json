{
    "docs": [
        {
            "location": "/", 
            "text": "About Donkey\n\n\nDonkey is a high level self driving library written in Python. It was \ndeveloped with a focus on enabling fast experimentation and easy contribution.\n\n\n\n\nBuild your own Donkey2\n\n\nDonkey2 is the standard car that most people build first. The parts cost $200\nand take 2 hours to assemble. Here are the main steps to build your own car: \n\n\n\n\nAssemble hardware.\n\n\nInstall software.\n\n\nCalibrate your car.\n\n\nStart driving.\n \n\n\nTrain an autopilot.\n \n\n\nExperiment with simulator.\n \n\n\n\n\n\n\nHello World.\n\n\nDonkeycar is designed to make adding new parts to your car easy. Here's and \nexample car application that captures images from the camera and saves them.\n\n\nimport donkey as dk\n\n#initialize the vehicle\nV = dk.Vehicle()\n\n#add a camera part\ncam = dk.parts.PiCamera()\nV.add(cam, outputs=['image'], threaded=True)\n\n#add tub part to record images\ntub = dk.parts.Tub(path='~/d2/gettings_started', \n                   inputs=['image'], \n                   types=['image_array'])\nV.add(tub, inputs=inputs)\n\n#start the vehicle's drive loop\nV.start(max_loop_count=100)\n\n\n\n\n\n\nInstallation\n\n\nFor linux/OS users clone the master branch to get the latest version.\n\n\ngit clone https://github.com/wroscoe/donkey donkeycar\npip install -e donkeycar\n\n\n\n\nHow to install on Windows\n\n\n\n\nWhy the name Donkey?\n\n\nThe ultimate goal of this project is to build something useful. Donkey's were\none of the first domesticated pack animals, they're notoriously stubborn, and \nthey are kid safe. Until the car can navigate from one side of a city to the \nother, we'll hold off naming it after some celestial being.", 
            "title": "Home"
        }, 
        {
            "location": "/#about-donkey", 
            "text": "Donkey is a high level self driving library written in Python. It was \ndeveloped with a focus on enabling fast experimentation and easy contribution.", 
            "title": "About Donkey"
        }, 
        {
            "location": "/#build-your-own-donkey2", 
            "text": "Donkey2 is the standard car that most people build first. The parts cost $200\nand take 2 hours to assemble. Here are the main steps to build your own car:    Assemble hardware.  Install software.  Calibrate your car.  Start driving.    Train an autopilot.    Experiment with simulator.", 
            "title": "Build your own Donkey2"
        }, 
        {
            "location": "/#hello-world", 
            "text": "Donkeycar is designed to make adding new parts to your car easy. Here's and \nexample car application that captures images from the camera and saves them.  import donkey as dk\n\n#initialize the vehicle\nV = dk.Vehicle()\n\n#add a camera part\ncam = dk.parts.PiCamera()\nV.add(cam, outputs=['image'], threaded=True)\n\n#add tub part to record images\ntub = dk.parts.Tub(path='~/d2/gettings_started', \n                   inputs=['image'], \n                   types=['image_array'])\nV.add(tub, inputs=inputs)\n\n#start the vehicle's drive loop\nV.start(max_loop_count=100)", 
            "title": "Hello World."
        }, 
        {
            "location": "/#installation", 
            "text": "For linux/OS users clone the master branch to get the latest version.  git clone https://github.com/wroscoe/donkey donkeycar\npip install -e donkeycar  How to install on Windows", 
            "title": "Installation"
        }, 
        {
            "location": "/#why-the-name-donkey", 
            "text": "The ultimate goal of this project is to build something useful. Donkey's were\none of the first domesticated pack animals, they're notoriously stubborn, and \nthey are kid safe. Until the car can navigate from one side of a city to the \nother, we'll hold off naming it after some celestial being.", 
            "title": "Why the name Donkey?"
        }, 
        {
            "location": "/guide/build_hardware/", 
            "text": "How to Build a Donkey V2\n\n\n\n\n\n\nOverview\n\n\nParts Included\n\n\nHardware:\n\n\nStep 1: Attach Raspberry Pi, Servo Driver, and Voltage Converter to 3D Printed Base Plate\n\n\nStep 2: Assemble Base Plate and Roll Cage\n\n\nStep 3: Connect Servo Driver and Voltage Converter to Raspberry Pi\n\n\nStep 4: Attach Camera\n\n\nStep 5: Put it all together\n\n\n\n\n\n\nSoftware\n\n\n\n\n\n\nOverview\n\n\nThese are instructions for the \nDonkey Car Starter Kit\n purchased from \nRobocar Store\n.\nFor instructions of the vanilla Donkey Car, please visit https://docs.donkeycar.com.\n\n\n\n\nParts Included:\n\n\n\n\n\n\n\n\nPart Description\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nHSP 94186 Remote Controlled Car\n\n\n1\n\n\n\n\n\n\nNiMH Battery\n\n\n1\n\n\n\n\n\n\nNiMH Battery Charger\n\n\n1\n\n\n\n\n\n\nHSP 94186 Manual / Stickers / Accessories\n\n\n1\n\n\n\n\n\n\nRaspberry Pi 3B\n\n\n1\n\n\n\n\n\n\n3D Printed Roll Cage\n\n\n1\n\n\n\n\n\n\n3D Printed Base Plate\n\n\n1\n\n\n\n\n\n\nWide Angle Camera\n\n\n1\n\n\n\n\n\n\nCamera Cable\n\n\n1\n\n\n\n\n\n\nFemale-Female Jumper Wire\n\n\n4\n\n\n\n\n\n\n16GB Micro SD Card\n\n\n1\n\n\n\n\n\n\nSD Card Adapter\n\n\n1\n\n\n\n\n\n\n16-Channel Servo Driver PCA9685\n\n\n1\n\n\n\n\n\n\nDC-DC 5V/2A Voltage Converter\n\n\n1\n\n\n\n\n\n\nM3x12mm Screws\n\n\n3\n\n\n\n\n\n\nM2.3x6mm PT Screws\n\n\n10\n\n\n\n\n\n\nM2x6mm Screws\n\n\n4\n\n\n\n\n\n\nMini Tamiya splitter\n\n\n1\n\n\n\n\n\n\nUSB Cable\n\n\n1\n\n\n\n\n\n\n\n\nHardware\n\n\n\n\nStep 1: Attach Raspberry Pi, Servo Driver, and Voltage Converter to 3D Printed Base Plate\n\n\nAttaching the Raspberry Pi, Servo Driver, and Voltage Converter is as simple as running screws through the board into the screw bosses on the base plate.  The 10 M2.3x6mm screws should be perfect to go through the holes and hold the components securely.  The ethernet and USB ports should face forward.  This is important as it gives you access to the SD card and makes the camera ribbon cable line up properly.\n\n\n\n\n\n\nStep 2: Assemble Base Plate and Roll Cage\n\n\nUse the 3 M3x12mm screws from the bottom of the base plate to attach and hold the roll cage on top of it.\n\n\n\n\nStep 3: Connect Servo Driver and Voltage Converter to Raspberry Pi\n\n\nYou could do this after attaching the Raspberry Pi to the base plate, I just think it is easier to see the parts when they are laying on the workbench.  Connect the parts as you see below:\n\n\n\n\nFor reference, below is the Raspberry Pi Pinout for reference.  You will notice we connect to 3.3v, the two I2C pins (SDA and SCL) and ground:\n\n\n\n\nAttach the open end of the mini Tamiya splitter to the Voltage Converter.  Loosen the screws in the blue connectors of the Voltage Converter and connect red wire to the IN+ side and black wire to the IN- side.  Attached the female mini Tamiya adapter to the wire from the ESC of the car.  Leave the male adapter for now, it will be connected to the battery to draw power for the Raspberry Pi before you start the car.  Attach the USB cable between the Voltage Converter and the Raspberry Pi.\n\n\n\n\n\n\nStep 4: Attach Camera\n\n\nAttaching the camera is a little tricky, the M2x6mm screws can be screwed into the plastic but it is a little hard.  I recommend drilling the holes out with a 1.5mm bit (1/16th bit in Imperial land) then pre threading them with the screws before putting the camera on. It is only necessary to put two screws in.\n\n\n\n\nSometimes using the two top screw holes can result in a short. Put screws in the bottom two holes.\n\n\n\n\nBefore using the car, remove the plastic cap from the camera lens.\n\n\n\n\nIt is easy to put the camera cable in the wrong way so look at these photos and make sure the cable is put in properly.  There are loads of tutorials on youtube if you are not used to this.\n\n\n\n\n\n\nStep 5: Put it all together\n\n\nThe final steps are straightforward.  First attach the roll bar assembly to the car.  This is done using the same pins that came with the vehicle.  \n\n\n\n\nSecond run the servo cables up to the car.  The throttle cable runs to channel 0 on the servo controller and steering is channel 1.\n\n\n\n\nNow you are done with the hardware!!\n\n\n\n\nSoftware\n\n\nCongrats!  Now to get your get your car moving, see the \nsoftware instructions\n section.\n\n\n\n\n\n\nWe are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.", 
            "title": "Build a car."
        }, 
        {
            "location": "/guide/build_hardware/#how-to-build-a-donkey-v2", 
            "text": "Overview  Parts Included  Hardware:  Step 1: Attach Raspberry Pi, Servo Driver, and Voltage Converter to 3D Printed Base Plate  Step 2: Assemble Base Plate and Roll Cage  Step 3: Connect Servo Driver and Voltage Converter to Raspberry Pi  Step 4: Attach Camera  Step 5: Put it all together    Software", 
            "title": "How to Build a Donkey V2"
        }, 
        {
            "location": "/guide/build_hardware/#overview", 
            "text": "These are instructions for the  Donkey Car Starter Kit  purchased from  Robocar Store .\nFor instructions of the vanilla Donkey Car, please visit https://docs.donkeycar.com.", 
            "title": "Overview"
        }, 
        {
            "location": "/guide/build_hardware/#parts-included", 
            "text": "Part Description  Quantity      HSP 94186 Remote Controlled Car  1    NiMH Battery  1    NiMH Battery Charger  1    HSP 94186 Manual / Stickers / Accessories  1    Raspberry Pi 3B  1    3D Printed Roll Cage  1    3D Printed Base Plate  1    Wide Angle Camera  1    Camera Cable  1    Female-Female Jumper Wire  4    16GB Micro SD Card  1    SD Card Adapter  1    16-Channel Servo Driver PCA9685  1    DC-DC 5V/2A Voltage Converter  1    M3x12mm Screws  3    M2.3x6mm PT Screws  10    M2x6mm Screws  4    Mini Tamiya splitter  1    USB Cable  1", 
            "title": "Parts Included:"
        }, 
        {
            "location": "/guide/build_hardware/#hardware", 
            "text": "", 
            "title": "Hardware"
        }, 
        {
            "location": "/guide/build_hardware/#step-1-attach-raspberry-pi-servo-driver-and-voltage-converter-to-3d-printed-base-plate", 
            "text": "Attaching the Raspberry Pi, Servo Driver, and Voltage Converter is as simple as running screws through the board into the screw bosses on the base plate.  The 10 M2.3x6mm screws should be perfect to go through the holes and hold the components securely.  The ethernet and USB ports should face forward.  This is important as it gives you access to the SD card and makes the camera ribbon cable line up properly.", 
            "title": "Step 1: Attach Raspberry Pi, Servo Driver, and Voltage Converter to 3D Printed Base Plate"
        }, 
        {
            "location": "/guide/build_hardware/#step-2-assemble-base-plate-and-roll-cage", 
            "text": "Use the 3 M3x12mm screws from the bottom of the base plate to attach and hold the roll cage on top of it.", 
            "title": "Step 2: Assemble Base Plate and Roll Cage"
        }, 
        {
            "location": "/guide/build_hardware/#step-3-connect-servo-driver-and-voltage-converter-to-raspberry-pi", 
            "text": "You could do this after attaching the Raspberry Pi to the base plate, I just think it is easier to see the parts when they are laying on the workbench.  Connect the parts as you see below:   For reference, below is the Raspberry Pi Pinout for reference.  You will notice we connect to 3.3v, the two I2C pins (SDA and SCL) and ground:   Attach the open end of the mini Tamiya splitter to the Voltage Converter.  Loosen the screws in the blue connectors of the Voltage Converter and connect red wire to the IN+ side and black wire to the IN- side.  Attached the female mini Tamiya adapter to the wire from the ESC of the car.  Leave the male adapter for now, it will be connected to the battery to draw power for the Raspberry Pi before you start the car.  Attach the USB cable between the Voltage Converter and the Raspberry Pi.", 
            "title": "Step 3: Connect Servo Driver and Voltage Converter to Raspberry Pi"
        }, 
        {
            "location": "/guide/build_hardware/#step-4-attach-camera", 
            "text": "Attaching the camera is a little tricky, the M2x6mm screws can be screwed into the plastic but it is a little hard.  I recommend drilling the holes out with a 1.5mm bit (1/16th bit in Imperial land) then pre threading them with the screws before putting the camera on. It is only necessary to put two screws in.   Sometimes using the two top screw holes can result in a short. Put screws in the bottom two holes.   Before using the car, remove the plastic cap from the camera lens.   It is easy to put the camera cable in the wrong way so look at these photos and make sure the cable is put in properly.  There are loads of tutorials on youtube if you are not used to this.", 
            "title": "Step 4: Attach Camera"
        }, 
        {
            "location": "/guide/build_hardware/#step-5-put-it-all-together", 
            "text": "The final steps are straightforward.  First attach the roll bar assembly to the car.  This is done using the same pins that came with the vehicle.     Second run the servo cables up to the car.  The throttle cable runs to channel 0 on the servo controller and steering is channel 1.   Now you are done with the hardware!!", 
            "title": "Step 5: Put it all together"
        }, 
        {
            "location": "/guide/build_hardware/#software", 
            "text": "Congrats!  Now to get your get your car moving, see the  software instructions  section.    We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.", 
            "title": "Software"
        }, 
        {
            "location": "/guide/install_software/", 
            "text": "Install Software\n\n\nThis guide will help you to setup the software to run Donkey on your Raspberry Pi, as well as the host PC operating system of your choice.  This guide uses a fork maintained by robocarstore, if you would like to use the default Donkey Car software, please follow the instructions on \nofficial instructions\n.\n\n\n\n\nSetup \nRaspberryPi\n\n\nSetup \nLinux Host PC\n\n\nSetup \nWindows Host PC\n\n\nSetup \nMac Host PC\n\n\n\n\n\n\nGet the Raspberry Pi working.\n\n\nBefore we can do anything we have to get our car's computer connected to the \ninternet. The fastest way is to use the disk image created for donkey cars. \n\n\nThe method for using a disk image to create a bootable SD card varies between\noperating systems. These instructions are for Ubuntu but you can see more \ninstructions \nhere\n.\n\n\n\n\nDownload prebuilt \nzipped disk image\n (1.1GB).\n\n\nUnzip the disk image.\n\n\nPlug your SD card into your computer.\n\n\nOpen the \"Startup Disk Creator\" application.\n\n\nSelect your source disk image as the one you unzipped earlier.\n\n\nSelect your SD card as the disk to use. \n\n\nClick \"Make startup disk\".\n\n\n\n\nSetup the Pi's WiFi for first boot\n\n\nWe can create a special file which will be used to login to wifi on first boot. More reading \nhere\n, but we will walk you through it. \n\n\nOn Windows, with your memory card image burned and memory disc still inserted, you should see two drives, which are actually two partitions on the mem disc. One is labeled \nboot\n. On Mac and Linux, you should also have access to the \nboot\n partition of the mem disc. This is formated with the common FAT type and is where we will edit some files to help it find and log-on to your wifi on it's first boot.\n\n\n\n\nStart a text editor: \ngedit\n on Linux. Notepad on Windows. TextEdit on a Mac.\n\n\nPaste and edit this contents to match your wifi:\n\n\n\n\ncountry=US\nctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\nupdate_config=1\n\nnetwork={\n    ssid=\nyour network name\n\n    psk=\nyour password\n\n}\n\n\n\n\n\nReplace \nyour network name\n with the ID of your network. Leave the quotes. I've seen problems when the network name contained an apostrophe, like \"Joe's iPhone\".\nReplace \nyour password\n with your password, leaving it surrounded by quotes. \nIf it bothers you to leave your password unencrypted, you may change the \ncontents later\n once you've gotten the pi to boot and log-in.\n\n\n\n\nSave this file to the root of \nboot\n partition with the filename \nwpa_supplicant.conf\n. On first boot, this file will be moved to \n/etc/wpa_supplicant/wpa_supplicant.conf\n where it may be edited later.\n\n\n\n\nSetup Pi's Hostname\n\n\nWe can also setup the hostname so that your Pi easier to find once on the network. If yours is the only Pi on the network, then you can find it with \n\n\nping d2.local\n\n\n\n\nonce it's booted. If there are many other Pi's on the network, then this will have problems. If you are on a Linux machine, or are able to edit the UUID partition, then you can edit the \n/etc/hostname\n and \n/etc/hosts\n files now to make finding your pi on the network easier after boot. Edit those to replace \nraspberrypi\n with a name of your choosing. Use all lower case, no special characters, no hyphens, no underscores \n_\n. \n\n\nsudo vi /media/userID/UUID/etc/hostname\nsudo vi /media/userID/UUID/etc/hosts\n\n\n\n\nNow you're SD card is ready. Eject it from your computer, put it in the Pi \nand plug in the Pi.\n\n\nConnecting to the Pi\n\n\nIf you followed the above instructions to add wifi access you're Pi should\nnow be connected to your wifi network. Now you need to find it's IP address\nso you can connect to it via SSH. \n\n\nThe easiest way (on Ubuntu) is to use the \nfindcar\n donkey command. You can try \nping raspberrypi.local\n. If you've modified the hostname, then you should try: \nping \nyour hostname\n.local\n. This will fail on a windows machine. Windows users will need the full IP address (unless using cygwin). \n\n\nIf you are having troubles locating your Pi on the network, you will want to plug in an HDMI monitor and USB keyboard into the Pi. Boot it. Login with:\n\n\n\n\nUsername: \npi\n\n\nPassword: \nasdfasdf\n\n\nThe older disk images use the password \nraspberry\n\n\n\n\nThen try the command:\n\n\nifconfig wlan0\n\n\n\n\nIf this has a valid IPv4 address, 4 groups of numbers separated by dots, then you can try that with your SSH command. If you don't see anything like that, then your wifi config might have a mistake. You can try to fix with\n\n\nsudo nano /etc/wpa_supplicant/wpa_supplicant.conf\n\n\n\n\nIf you don't have a HDMI monitor and keyboard, you can plug-in the Pi with a CAT5 cable to a router with DHCP. If that router is on the same network as your PC, you can try:\n\n\nping d2.local\n\n\n\n\nHopefully, one of those methods worked and you are now ready to SSH into your Pi. On Mac and Linux, you can open Terminal. On Windows you can install \nPutty\n or \none of the alternatives\n.\n\n\nIf you have a command prompt, you can try:\n\n\nssh pi@d2.local\n\n\n\n\nor\n\n\nssh pi@\nyour pi ip address\n\n\n\n\n\nor via Putty:\n\n Username: \npi\n\n\n Password: \nasdfasdf\n\n  * \nasdfasdf\n on the current v22 prebuilt image linked above.\n  * \nraspberry\n on older images/manual installs\n* Hostname:\nyour pi IP address\n\n\nIf you are using the prebuilt image specified above, then your Pi is ready to go. You should see a d2 and donkey directory. \n\n\n\n\nNote: Check config.py to make sure it uses the correct settings for the PWM channel for steering and throttle. Open config.py \nnano ~/d2/config.py\n and make sure that you see the lines:\n\n\n\n\nSTEERING_CHANNEL = 1\n\n\nTHROTTLE_CHANNEL = 0\n\n\n\n\nThe 1 and 0 for the parts arguments should match whichever channel you used to plug your servo/ESC leads in to your 9685 board. Usually this ranges from 0-15 and it numbered on the board.\n\n\nNote: If you are using the prebuilt image specified above, your Pi is not using the full capacity of the SD card. To make the full capacity accessible, SSH into the Pi and run \nsudo raspi-config\n to go into the configuration tool. Select \n7 Advanced Options\n and \nA1 Expand Filesystem\n. And then select \nFinish\n to exit the configuration tool and reboot. The Pi can access the full capacity of the SD card now.\n\n\n\n\nUpdate Donkeycar Python code and install\n\n\nThe donkeycar Python code on the memory card image is likely older than the that on the Github repo, so update things once you have the Pi running.\n\n\ncd ~/donkeycar\ngit pull\npip install -e .\n\n\n\n\n\n\nNow let's setup the same donkey library on your laptop or server so you can test and train autopilots. Install varies \ndepending on platform.\n\n\nInstall donkeycar on Linux\n\n\nInstall dependencies, setup virtualenv\n\n\nsudo apt-get install virtualenv build-essential python3-dev gfortran libhdf5-dev\nvirtualenv env -p python3\nsource env/bin/activate\npip install keras==2.0.6\npip install tensorflow==1.3.0\n\n\n\n\n\n\nInstall donkey source and create your local working dir:\n\n\n\n\ngit clone https://github.com/robocarstore/donkey donkeycar\npip install -e donkeycar\n\n\n\n\nNext: Calibrate your car.\n\n\n\n\nInstall donkeycar on Windows\n\n\n\n\n\n\nInstall \nminiconda Python 3.6 64 bit\n. Be sure to check the box to allow it to modify your system path variable to add conda.\n\n\n\n\n\n\nInstall \ngit 64 bit\n\n\n\n\n\n\nFrom the start menu start the Anaconda Prompt.\n\n\n\n\n\n\nChange to a dir you would like to use as the head of your projects.\n\n\n\n\n\n\nmkdir projects\ncd projects\n\n\n\n\n\n\nGet the latest donkey from Github.\n\n\n\n\ngit clone https://github.com/robocarstore/donkey\ncd donkey\n\n\n\n\n\n\nCreate the Python Anaconda environment\n\n\n\n\nconda env create -f envs\\windows.yml\nactivate donkey\n\n\n\n\n\n\nInstall donkey source and create your local working dir:\n\n\n\n\npip install -e .\ndonkey createcar --path ~/d2\n\n\n\n\n\n\nNote: After closing the Anaconda Prompt, when you open it again, you will need to \ntype \nactivate donkey\n to re-enable the mappings to donkey specific \nPython libraries\n\n\n\n\nNext: Calibrate your car.\n\n\n\n\nInstall donkeycar on Mac\n\n\n\n\n\n\nInstall \nminiconda Python 3.6 64 bit\n\n\n\n\n\n\nInstall \ngit 64 bit\n\n\n\n\n\n\nStart Terminal\n\n\n\n\n\n\nIf Xcode or gcc not installed - run the following command to install Command Line Tools for Xcode.\n\n\n\n\n\n\nxcode-select --install\n\n\n\n\n\n\nChange to a dir you would like to use as the head of your projects.\n\n\n\n\nmkdir projects\ncd projects\n\n\n\n\n\n\nGet the latest donkey from Github.\n\n\n\n\ngit clone https://github.com/robocarstore/donkey\ncd donkey\n\n\n\n\n\n\nCreate the Python anaconda environment\n\n\n\n\nconda env create -f envs/mac.yml\nsource activate donkey\n\n\n\n\n\n\nInstall Tensorflow\n\n\n\n\npip install https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-1.3.0-py3-none-any.whl\n\n\n\n\n\n\nInstall donkey source and create your local working dir:\n\n\n\n\npip install -e .\ndonkey createcar --path ~/d2\n\n\n\n\nNext: Calibrate your car.\n\n\n\n\nNote: After closing the Terminal, when you open it again, you will need to \ntype \nsource activate donkey\n to re-enable the mappings to donkey specific \nPython libraries\n\n\n\n\n\n\nInstall another fork of donkeycar\n\n\nOccasionally you may want to run with changes from a separate fork of donkey. You may uninstall one and install another. That's fastest, but leaves you with only the forked version installed:\n\n\npip uninstall donkeycar\ngit clone --depth=1 https://github.com/\nusername\n/donkey donkey_\nusername\n\ncd donkey_\nusername\n\npip install -e .\n\n\n\n\nTo get back to the stock donkey install:\n\n\npip uninstall donkeycar\ngit clone --depth=1 https://github.com/robocarstore/donkey donkey\ncd donkey\npip install -e .", 
            "title": "Install the software."
        }, 
        {
            "location": "/guide/install_software/#install-software", 
            "text": "This guide will help you to setup the software to run Donkey on your Raspberry Pi, as well as the host PC operating system of your choice.  This guide uses a fork maintained by robocarstore, if you would like to use the default Donkey Car software, please follow the instructions on  official instructions .   Setup  RaspberryPi  Setup  Linux Host PC  Setup  Windows Host PC  Setup  Mac Host PC", 
            "title": "Install Software"
        }, 
        {
            "location": "/guide/install_software/#get-the-raspberry-pi-working", 
            "text": "Before we can do anything we have to get our car's computer connected to the \ninternet. The fastest way is to use the disk image created for donkey cars.   The method for using a disk image to create a bootable SD card varies between\noperating systems. These instructions are for Ubuntu but you can see more \ninstructions  here .   Download prebuilt  zipped disk image  (1.1GB).  Unzip the disk image.  Plug your SD card into your computer.  Open the \"Startup Disk Creator\" application.  Select your source disk image as the one you unzipped earlier.  Select your SD card as the disk to use.   Click \"Make startup disk\".", 
            "title": "Get the Raspberry Pi working."
        }, 
        {
            "location": "/guide/install_software/#setup-the-pis-wifi-for-first-boot", 
            "text": "We can create a special file which will be used to login to wifi on first boot. More reading  here , but we will walk you through it.   On Windows, with your memory card image burned and memory disc still inserted, you should see two drives, which are actually two partitions on the mem disc. One is labeled  boot . On Mac and Linux, you should also have access to the  boot  partition of the mem disc. This is formated with the common FAT type and is where we will edit some files to help it find and log-on to your wifi on it's first boot.   Start a text editor:  gedit  on Linux. Notepad on Windows. TextEdit on a Mac.  Paste and edit this contents to match your wifi:   country=US\nctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\nupdate_config=1\n\nnetwork={\n    ssid= your network name \n    psk= your password \n}  Replace  your network name  with the ID of your network. Leave the quotes. I've seen problems when the network name contained an apostrophe, like \"Joe's iPhone\".\nReplace  your password  with your password, leaving it surrounded by quotes. \nIf it bothers you to leave your password unencrypted, you may change the  contents later  once you've gotten the pi to boot and log-in.   Save this file to the root of  boot  partition with the filename  wpa_supplicant.conf . On first boot, this file will be moved to  /etc/wpa_supplicant/wpa_supplicant.conf  where it may be edited later.", 
            "title": "Setup the Pi's WiFi for first boot"
        }, 
        {
            "location": "/guide/install_software/#setup-pis-hostname", 
            "text": "We can also setup the hostname so that your Pi easier to find once on the network. If yours is the only Pi on the network, then you can find it with   ping d2.local  once it's booted. If there are many other Pi's on the network, then this will have problems. If you are on a Linux machine, or are able to edit the UUID partition, then you can edit the  /etc/hostname  and  /etc/hosts  files now to make finding your pi on the network easier after boot. Edit those to replace  raspberrypi  with a name of your choosing. Use all lower case, no special characters, no hyphens, no underscores  _ .   sudo vi /media/userID/UUID/etc/hostname\nsudo vi /media/userID/UUID/etc/hosts  Now you're SD card is ready. Eject it from your computer, put it in the Pi \nand plug in the Pi.", 
            "title": "Setup Pi's Hostname"
        }, 
        {
            "location": "/guide/install_software/#connecting-to-the-pi", 
            "text": "If you followed the above instructions to add wifi access you're Pi should\nnow be connected to your wifi network. Now you need to find it's IP address\nso you can connect to it via SSH.   The easiest way (on Ubuntu) is to use the  findcar  donkey command. You can try  ping raspberrypi.local . If you've modified the hostname, then you should try:  ping  your hostname .local . This will fail on a windows machine. Windows users will need the full IP address (unless using cygwin).   If you are having troubles locating your Pi on the network, you will want to plug in an HDMI monitor and USB keyboard into the Pi. Boot it. Login with:   Username:  pi  Password:  asdfasdf  The older disk images use the password  raspberry   Then try the command:  ifconfig wlan0  If this has a valid IPv4 address, 4 groups of numbers separated by dots, then you can try that with your SSH command. If you don't see anything like that, then your wifi config might have a mistake. You can try to fix with  sudo nano /etc/wpa_supplicant/wpa_supplicant.conf  If you don't have a HDMI monitor and keyboard, you can plug-in the Pi with a CAT5 cable to a router with DHCP. If that router is on the same network as your PC, you can try:  ping d2.local  Hopefully, one of those methods worked and you are now ready to SSH into your Pi. On Mac and Linux, you can open Terminal. On Windows you can install  Putty  or  one of the alternatives .  If you have a command prompt, you can try:  ssh pi@d2.local  or  ssh pi@ your pi ip address   or via Putty:  Username:  pi   Password:  asdfasdf \n  *  asdfasdf  on the current v22 prebuilt image linked above.\n  *  raspberry  on older images/manual installs\n* Hostname: your pi IP address  If you are using the prebuilt image specified above, then your Pi is ready to go. You should see a d2 and donkey directory.    Note: Check config.py to make sure it uses the correct settings for the PWM channel for steering and throttle. Open config.py  nano ~/d2/config.py  and make sure that you see the lines:   STEERING_CHANNEL = 1  THROTTLE_CHANNEL = 0   The 1 and 0 for the parts arguments should match whichever channel you used to plug your servo/ESC leads in to your 9685 board. Usually this ranges from 0-15 and it numbered on the board.  Note: If you are using the prebuilt image specified above, your Pi is not using the full capacity of the SD card. To make the full capacity accessible, SSH into the Pi and run  sudo raspi-config  to go into the configuration tool. Select  7 Advanced Options  and  A1 Expand Filesystem . And then select  Finish  to exit the configuration tool and reboot. The Pi can access the full capacity of the SD card now.", 
            "title": "Connecting to the Pi"
        }, 
        {
            "location": "/guide/install_software/#update-donkeycar-python-code-and-install", 
            "text": "The donkeycar Python code on the memory card image is likely older than the that on the Github repo, so update things once you have the Pi running.  cd ~/donkeycar\ngit pull\npip install -e .   Now let's setup the same donkey library on your laptop or server so you can test and train autopilots. Install varies \ndepending on platform.", 
            "title": "Update Donkeycar Python code and install"
        }, 
        {
            "location": "/guide/install_software/#install-donkeycar-on-linux", 
            "text": "Install dependencies, setup virtualenv  sudo apt-get install virtualenv build-essential python3-dev gfortran libhdf5-dev\nvirtualenv env -p python3\nsource env/bin/activate\npip install keras==2.0.6\npip install tensorflow==1.3.0   Install donkey source and create your local working dir:   git clone https://github.com/robocarstore/donkey donkeycar\npip install -e donkeycar  Next: Calibrate your car.", 
            "title": "Install donkeycar on Linux"
        }, 
        {
            "location": "/guide/install_software/#install-donkeycar-on-windows", 
            "text": "Install  miniconda Python 3.6 64 bit . Be sure to check the box to allow it to modify your system path variable to add conda.    Install  git 64 bit    From the start menu start the Anaconda Prompt.    Change to a dir you would like to use as the head of your projects.    mkdir projects\ncd projects   Get the latest donkey from Github.   git clone https://github.com/robocarstore/donkey\ncd donkey   Create the Python Anaconda environment   conda env create -f envs\\windows.yml\nactivate donkey   Install donkey source and create your local working dir:   pip install -e .\ndonkey createcar --path ~/d2   Note: After closing the Anaconda Prompt, when you open it again, you will need to \ntype  activate donkey  to re-enable the mappings to donkey specific \nPython libraries   Next: Calibrate your car.", 
            "title": "Install donkeycar on Windows"
        }, 
        {
            "location": "/guide/install_software/#install-donkeycar-on-mac", 
            "text": "Install  miniconda Python 3.6 64 bit    Install  git 64 bit    Start Terminal    If Xcode or gcc not installed - run the following command to install Command Line Tools for Xcode.    xcode-select --install   Change to a dir you would like to use as the head of your projects.   mkdir projects\ncd projects   Get the latest donkey from Github.   git clone https://github.com/robocarstore/donkey\ncd donkey   Create the Python anaconda environment   conda env create -f envs/mac.yml\nsource activate donkey   Install Tensorflow   pip install https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-1.3.0-py3-none-any.whl   Install donkey source and create your local working dir:   pip install -e .\ndonkey createcar --path ~/d2  Next: Calibrate your car.   Note: After closing the Terminal, when you open it again, you will need to \ntype  source activate donkey  to re-enable the mappings to donkey specific \nPython libraries", 
            "title": "Install donkeycar on Mac"
        }, 
        {
            "location": "/guide/install_software/#install-another-fork-of-donkeycar", 
            "text": "Occasionally you may want to run with changes from a separate fork of donkey. You may uninstall one and install another. That's fastest, but leaves you with only the forked version installed:  pip uninstall donkeycar\ngit clone --depth=1 https://github.com/ username /donkey donkey_ username \ncd donkey_ username \npip install -e .  To get back to the stock donkey install:  pip uninstall donkeycar\ngit clone --depth=1 https://github.com/robocarstore/donkey donkey\ncd donkey\npip install -e .", 
            "title": "Install another fork of donkeycar"
        }, 
        {
            "location": "/guide/get_driving/", 
            "text": "Drive your car.\n\n\nAfter you've calibrated your car you can start driving it. \n\n\nStart your car.\n\n\n\n\n Put your car in a safe place where the wheels are off the ground \n\nThis is the step were the car can take off. \n\n\n\n\n\n\nNormal usage\n\n\nIn future runs, when you start a new session, you will want to:\n\n\nOn Windows:\n\n\n\n\nstart a new Anaconda Prompt from Windows start menu\n\n\nActivate mappings to donkey Python setup with: \nactivate donkey\n\n\nChange to your local dir for managing donkey: \ncd ~/d2\n\n\nFind your pi\n\n\n\n\nThis will show your IP address, prompt for your password, and then search \nfor your cars IP address. \n\n\n\n\nIf your car's IP address is not shown:\n\n\n\n\nFind another way to scan your local network for your raspberry pi \n\n\nConnect a monitor/keyboard and ensure your pi is connected to the the same wifi network as your computer. \n\n\n\n\n\n\nAssuming that you did find your pi on the network, you can now connect to it via SSH. \n\n\nssh pi@\nyour_pi_ip_address\n\n\n\n\n\nThe default user name is 'pi' and the password is 'raspberry'.  If you are using the pre-built Donkey image, the password is 'asdfasdf'.\n\n\nMake sure you've created your car application.\n\n\ndonkey createcar --template donkey2 --path ~/d2\n\n\n\n\nSee also \nmore information.\n\n\nStart your car.\n\n\nOpen your car's folder and start your car. \n\n\ncd ~/d2\npython manage.py drive\n\n\n\n\nThis script will start the drive loop in your car which includes a part that \nis a web server for you to control your car. You can now control your car\nfrom a web browser at the URL: \nyour car's IP's address\n:8887\n\n\n\n\nDriving with Web Controller\n\n\nOn your phone you can now press start to set your phones current tilt to be\nzero throttle and steering. Now tilting your phone forward will increase throttle and tilting it side to side will turn the steering. \n\n\nFeatures\n\n\n\n\nRecording - Press record data to start recording images, steering angels and throttle values. \n\n\nThrottle mode - Option to set the throttle as constant. This is used in \nraces if you have a pilot that will steer but doesn't control throttle. \n\n\nPilot mode - Choose this if the pilot should control the angle and/or throttle.\n\n\nMax throttle - Select the maximum throttle.\n\n\n\n\nKeyboard shortcuts\n\n\n\n\nspace\n : stop car and stop recording\n\n\nr\n : toggle recording\n\n\ni\n : increase throttle\n\n\nk\n : decrease throttle\n\n\nj\n : turn left \n\n\nl\n : turn right \n\n\n\n\n\n\nDriving with Physical Joystick Controller\n\n\nYou may find that it helps to use a physical joystick device to control your vehicle.\n\n\nSetup Bluetooth and pair joystick\n\n\nCheck the \nControllers\n section to read about setting up the bluetooth connection.\n\n\nStart car\n\n\ncd ~/d2\npython manage.py drive --js\n\n\n\n\nOptionally, if you want joystick use to be sticky and don't want to add the --js each time, modify your config.py so that USE_JOYSTICK_AS_DEFAULT = True\n\n\nnano config.py\n\n\n\n\nJoystick Controls\n\n\n\n\nLeft analog stick - Left and right to adjust steering\n\n\nRight analog stick - Forward to increase forward throttle\n\n\nPull back twice on right analog to reverse\n\n\n\n\n\n\nWhenever the throttle is not zero, driving data will be recorded - as long as you are in User mode!\n\n\n\n\n\n\nSelect button switches modes - \"User, Local Angle, Local(angle and throttle)\"\n\n\nTriangle - Increase max throttle\n\n\nX  - Decrease max throttle\n\n\nCircle - Toggle recording (disabled by default. auto record on throttle is enabled by default)\n\n\ndpad up - Increase throttle scale\n\n\ndpad down - Decrease throttle scale\n\n\ndpad left - Increase steering scale\n\n\ndpad right - Decrease steering scale\n\n\nStart - Toggle constant throttle. Sets to max throttle (modified by X and Triangle).\n\n\n\n\nStart car for self-driving\n\n\ncd ~/d2\npython manage.py drive --model \npath/to/model\n --js\n\n\n\n\nHit the Select button to toggle between three modes - User, Local Angle, and Local Throttle \n Angle.\n\n\n\n\nUser - User controls both steering and throttle with joystick\n\n\nLocal Angle - Ai controls steering, user controls throttle\n\n\nLocal Throttle \n Angle - Ai controls both steering and throttle\n\n\n\n\nWhen the car is in Local Angle mode, the NN will steer. You must provide throttle.", 
            "title": "Get driving."
        }, 
        {
            "location": "/guide/get_driving/#drive-your-car", 
            "text": "After you've calibrated your car you can start driving it.", 
            "title": "Drive your car."
        }, 
        {
            "location": "/guide/get_driving/#start-your-car", 
            "text": "Put your car in a safe place where the wheels are off the ground  \nThis is the step were the car can take off.", 
            "title": "Start your car."
        }, 
        {
            "location": "/guide/get_driving/#normal-usage", 
            "text": "In future runs, when you start a new session, you will want to:  On Windows:   start a new Anaconda Prompt from Windows start menu  Activate mappings to donkey Python setup with:  activate donkey  Change to your local dir for managing donkey:  cd ~/d2  Find your pi   This will show your IP address, prompt for your password, and then search \nfor your cars IP address.    If your car's IP address is not shown:   Find another way to scan your local network for your raspberry pi   Connect a monitor/keyboard and ensure your pi is connected to the the same wifi network as your computer.     Assuming that you did find your pi on the network, you can now connect to it via SSH.   ssh pi@ your_pi_ip_address   The default user name is 'pi' and the password is 'raspberry'.  If you are using the pre-built Donkey image, the password is 'asdfasdf'.", 
            "title": "Normal usage"
        }, 
        {
            "location": "/guide/get_driving/#make-sure-youve-created-your-car-application", 
            "text": "donkey createcar --template donkey2 --path ~/d2  See also  more information.", 
            "title": "Make sure you've created your car application."
        }, 
        {
            "location": "/guide/get_driving/#start-your-car_1", 
            "text": "Open your car's folder and start your car.   cd ~/d2\npython manage.py drive  This script will start the drive loop in your car which includes a part that \nis a web server for you to control your car. You can now control your car\nfrom a web browser at the URL:  your car's IP's address :8887", 
            "title": "Start your car."
        }, 
        {
            "location": "/guide/get_driving/#driving-with-web-controller", 
            "text": "On your phone you can now press start to set your phones current tilt to be\nzero throttle and steering. Now tilting your phone forward will increase throttle and tilting it side to side will turn the steering.", 
            "title": "Driving with Web Controller"
        }, 
        {
            "location": "/guide/get_driving/#features", 
            "text": "Recording - Press record data to start recording images, steering angels and throttle values.   Throttle mode - Option to set the throttle as constant. This is used in \nraces if you have a pilot that will steer but doesn't control throttle.   Pilot mode - Choose this if the pilot should control the angle and/or throttle.  Max throttle - Select the maximum throttle.", 
            "title": "Features"
        }, 
        {
            "location": "/guide/get_driving/#keyboard-shortcuts", 
            "text": "space  : stop car and stop recording  r  : toggle recording  i  : increase throttle  k  : decrease throttle  j  : turn left   l  : turn right", 
            "title": "Keyboard shortcuts"
        }, 
        {
            "location": "/guide/get_driving/#driving-with-physical-joystick-controller", 
            "text": "You may find that it helps to use a physical joystick device to control your vehicle.", 
            "title": "Driving with Physical Joystick Controller"
        }, 
        {
            "location": "/guide/get_driving/#setup-bluetooth-and-pair-joystick", 
            "text": "Check the  Controllers  section to read about setting up the bluetooth connection.", 
            "title": "Setup Bluetooth and pair joystick"
        }, 
        {
            "location": "/guide/get_driving/#start-car", 
            "text": "cd ~/d2\npython manage.py drive --js  Optionally, if you want joystick use to be sticky and don't want to add the --js each time, modify your config.py so that USE_JOYSTICK_AS_DEFAULT = True  nano config.py", 
            "title": "Start car"
        }, 
        {
            "location": "/guide/get_driving/#joystick-controls", 
            "text": "Left analog stick - Left and right to adjust steering  Right analog stick - Forward to increase forward throttle  Pull back twice on right analog to reverse    Whenever the throttle is not zero, driving data will be recorded - as long as you are in User mode!    Select button switches modes - \"User, Local Angle, Local(angle and throttle)\"  Triangle - Increase max throttle  X  - Decrease max throttle  Circle - Toggle recording (disabled by default. auto record on throttle is enabled by default)  dpad up - Increase throttle scale  dpad down - Decrease throttle scale  dpad left - Increase steering scale  dpad right - Decrease steering scale  Start - Toggle constant throttle. Sets to max throttle (modified by X and Triangle).", 
            "title": "Joystick Controls"
        }, 
        {
            "location": "/guide/get_driving/#start-car-for-self-driving", 
            "text": "cd ~/d2\npython manage.py drive --model  path/to/model  --js  Hit the Select button to toggle between three modes - User, Local Angle, and Local Throttle   Angle.   User - User controls both steering and throttle with joystick  Local Angle - Ai controls steering, user controls throttle  Local Throttle   Angle - Ai controls both steering and throttle   When the car is in Local Angle mode, the NN will steer. You must provide throttle.", 
            "title": "Start car for self-driving"
        }, 
        {
            "location": "/guide/calibrate/", 
            "text": "Calibrate your Car\n\n\nThe point of calibrating your car is to make it drive consitently with\nother vehicles. These instructions \n\n\nHow to adjust your car's settings.\n\n\nAll of the car's settings are in the \nconfig.py\n script generated when \nyou ran the \ndonkey createcar --path ~/d2\n command. You can edit\nthis file on your car by running:\n\n\nnano ~/d2/config.py\n\n\n\n\nOur goal is to edit these settings so your car will drive like every\nother calibrated Donkey2. This way you'll be able to share pilots and \ndatasets between each car. \n\n\n\n\nYou will need to ssh into your Pi to do the calibration.\n\n\n\n\nSteering Calibration\n\n\n\n\nMake sure your car is off the ground to prevent a runaway situation.\n\n\n\n\n\n\nTurn on your car.\n\n\nFind the servo cable on your car and see what channel it's plugged into the\nPCA board. It should be 1 or 0.\n\n\nRun \ndonkey calibrate --channel \nyour_steering_channel\n\n\nEnter \n360' and you should see the wheels on your car move slightly. If not \nenter\n400\nor\n300`.\n\n\nNext enter values +/- 10 from your starting value to find the PWM setting\nthat makes your car turn all the way left and all the way right. Remember \nthese values. \n\n\nEnter these values in \nconfig.py\n script as \nSTEERING_RIGHT_PWM\n and \n\nSTEERING_LEFT_PWM\n. \n\n\n\n\nThrottle Calibration\n\n\n\n\nFind the cable coming from your ESC and see what channel it goes into the\nPCA board. This is your throttle channel.\n\n\nrun \ndonkey calibrate --channel \nyour_throttle_channel\n\n\nEnter \n370\n when prompted for a PWM value.\n\n\nYou should hear your ESC beep indicating that it's calibrated. \n\n\nEnter \n400\n and you should see your cars wheels start to go forward. If not,\nits likely that this is reverse, try entering \n330\n instead.\n\n\nKeep trying different values until you've found a reasonable max speed and\nremember this PWM value.\n\n\n\n\nReverse on RC cars is a little tricky because the ESC must receive a\nreverse pulse, zero pulse, reverse pulse to start to go backwards. To calibrate\na reverse PWM setting...\n\n\n\n\nUse the same technique as above set the PWM setting to your zero throttle. \n\n\nEnter the reverse value, then the zero throttle value, then the reverse \nvalue again. \n\n\nEnter values +/- 10 of the reverse value to find a reasonable reverse speed.\nRemember this reverse PWM value. \n\n\n\n\nNow open your \nconfig.py\n script and enter the PWM values for your car into\nthe throttle_controller part. \n\n \nTHROTTLE_FORWARD_PWM\n = PWM value for full throttle forward\n\n \nTHROTTLE_STOPPED_PWM\n = PWM value for zero throttle\n* \nTHROTTLE_REVERSE_PWM\n = PWM value at full reverse throttle\n\n\nFine tuning your calibration.\n\n\n\n\nNow that you have your car roughly calibrated you can try driving it to \nverify that it drives as expected. Here's how to fine tune your car's calibration. \n\n\n\n\nStart your car by running \npython manage.py drive\n.\n\n\nGo to \nyour_cars_ip_address\n:8887\n in a browser. \n\n\nPress \nj\n until the cars steering is all the way right. \n\n\nPress \ni\n a couple times to get the car to go forward.\n\n\nMeasure the diameter of the turn and record it on a spreadsheet. \n\n\nRepeat this measurement for different steering values for turning each \ndirection. \n\n\nChart these so you can see if your car turns the same in each direction. \n\n\n\n\nCorrections\n\n If your car turns the same amount at an 80% turn and a 100% turn, change the\nPWM setting for that turn direction to be the PWM value at 80%. \n\n If your car is biased to turn one direction, change the PWM values of your turns\nin the opposite direction of the bias.\n\n\nAfter you've fine tuned your car the steering chart should look something like\nthis.", 
            "title": "Calibrate steering and throttle."
        }, 
        {
            "location": "/guide/calibrate/#calibrate-your-car", 
            "text": "The point of calibrating your car is to make it drive consitently with\nother vehicles. These instructions", 
            "title": "Calibrate your Car"
        }, 
        {
            "location": "/guide/calibrate/#how-to-adjust-your-cars-settings", 
            "text": "All of the car's settings are in the  config.py  script generated when \nyou ran the  donkey createcar --path ~/d2  command. You can edit\nthis file on your car by running:  nano ~/d2/config.py  Our goal is to edit these settings so your car will drive like every\nother calibrated Donkey2. This way you'll be able to share pilots and \ndatasets between each car.    You will need to ssh into your Pi to do the calibration.", 
            "title": "How to adjust your car's settings."
        }, 
        {
            "location": "/guide/calibrate/#steering-calibration", 
            "text": "Make sure your car is off the ground to prevent a runaway situation.    Turn on your car.  Find the servo cable on your car and see what channel it's plugged into the\nPCA board. It should be 1 or 0.  Run  donkey calibrate --channel  your_steering_channel  Enter  360' and you should see the wheels on your car move slightly. If not \nenter 400 or 300`.  Next enter values +/- 10 from your starting value to find the PWM setting\nthat makes your car turn all the way left and all the way right. Remember \nthese values.   Enter these values in  config.py  script as  STEERING_RIGHT_PWM  and  STEERING_LEFT_PWM .", 
            "title": "Steering Calibration"
        }, 
        {
            "location": "/guide/calibrate/#throttle-calibration", 
            "text": "Find the cable coming from your ESC and see what channel it goes into the\nPCA board. This is your throttle channel.  run  donkey calibrate --channel  your_throttle_channel  Enter  370  when prompted for a PWM value.  You should hear your ESC beep indicating that it's calibrated.   Enter  400  and you should see your cars wheels start to go forward. If not,\nits likely that this is reverse, try entering  330  instead.  Keep trying different values until you've found a reasonable max speed and\nremember this PWM value.   Reverse on RC cars is a little tricky because the ESC must receive a\nreverse pulse, zero pulse, reverse pulse to start to go backwards. To calibrate\na reverse PWM setting...   Use the same technique as above set the PWM setting to your zero throttle.   Enter the reverse value, then the zero throttle value, then the reverse \nvalue again.   Enter values +/- 10 of the reverse value to find a reasonable reverse speed.\nRemember this reverse PWM value.    Now open your  config.py  script and enter the PWM values for your car into\nthe throttle_controller part.    THROTTLE_FORWARD_PWM  = PWM value for full throttle forward   THROTTLE_STOPPED_PWM  = PWM value for zero throttle\n*  THROTTLE_REVERSE_PWM  = PWM value at full reverse throttle", 
            "title": "Throttle Calibration"
        }, 
        {
            "location": "/guide/calibrate/#fine-tuning-your-calibration", 
            "text": "Now that you have your car roughly calibrated you can try driving it to \nverify that it drives as expected. Here's how to fine tune your car's calibration.    Start your car by running  python manage.py drive .  Go to  your_cars_ip_address :8887  in a browser.   Press  j  until the cars steering is all the way right.   Press  i  a couple times to get the car to go forward.  Measure the diameter of the turn and record it on a spreadsheet.   Repeat this measurement for different steering values for turning each \ndirection.   Chart these so you can see if your car turns the same in each direction.    Corrections  If your car turns the same amount at an 80% turn and a 100% turn, change the\nPWM setting for that turn direction to be the PWM value at 80%.   If your car is biased to turn one direction, change the PWM values of your turns\nin the opposite direction of the bias.  After you've fine tuned your car the steering chart should look something like\nthis.", 
            "title": "Fine tuning your calibration."
        }, 
        {
            "location": "/guide/train_autopilot/", 
            "text": "Train an autopilot with Keras\n\n\nNow that you're able to drive your car reliably you can use Keras to train a\nneural network to drive like you. Here are the steps.\n\n\nCollect Data\n\n\nMake sure you collect good data. \n\n\n\n\nPractice driving around the track a couple times without recording data.\n\n\nWhen you're confident you can drive 10 laps without mistake press \nStart Recording\n\n\nIf you crash or run off the track press Stop Car immediately to stop recording. \nA little bad data won't affect your autopilot. \n\n\nAfter you've collected 10-20 laps of good data (5-20k images) you can stop \nyour car with \nCtrl-c\n in the ssh session for your car.\n\n\nThe data you've collected is in the data folder in the most recent tub folder.\n\n\n\n\nTransfer data from your car to your computer.\n\n\nSince the Raspberry Pi is not very powerful, we need to transfer the data\nto a PC computer to train.\n\n\nIn a new terminal session on your host PC use rsync to copy your cars \nfolder from the raspberry pi.\n\n\nrsync -r pi@\nyour_pi_ip_address\n:~/d2/data/  ~/d2/data/\n\n\n\n\nTrain a model\n\n\n\n\nIn the same terminal you can now run the training script on the latest tub by passing the path to that tub as an argument. You can optionally pass path masks, such as \n./data/*\n or \n./data/tub_?_17-08-28\n to gather multiple tubs. For example:\n\n\n\n\n python ~/d2/manage.py train --tub \ntub folder names comma separated\n --model ./models/mypilot\n\n\n\n\nOptionally you can pass no arguments for the tub, and then all tubs will be used in the default data dir.\n\n\n python ~/d2/manage.py train --model ~/d2/models/mypilot\n\n\n\n\n\n\nNow you can use rsync again to move your pilot back to your car. \n\n\n\n\nrsync -r ~/d2/models/ pi@\nyour_ip_address\n:~/d2/models/\n\n\n\n\n\n\nNow you can start your car again and pass it your model to drive.\n\n\n\n\npython manage.py drive --model ~/d2/models/mypilot\n\n\n\n\nTraining Tips:\n\n\n\n\n\n\nMode \n Pilot\n: Congratulations on getting it this far. The first thing to note after running the command above, is to look at the options in the Mode \n Pilot menu. It can be pretty confusing. So here's what the different options mean:\n\n\na. \nUser\n : As you guessed, this is where you are in control of both the steering and throttle control.\n\n\nb. \nLocal Angle\n : Not too obvious, but this is where the trained model (mypilot from above) controls the steering. The \nLocal\n refers to the trained model which is locally hosted on the raspberry-pi.\n\n\nc. \nLocal Pilot\n : This is where the trained model (mypilot) assumes control of both the steering and the throttle. As of now, it's purportedly not very reliable.\n\n\nBe sure to also check out the \nMax Throttle\n and \nThrottle Mode\n options, and play around with a few settings. Can help with training quite a lot. \n\n\n\n\n\n\nBuild a Simple Track\n : This isn't very well-documented, but the car should (theoretically) be able to train against any kind of track. To start off with, it might not be necessary to build a two-lane track with a striped center-lane. Try with a single lane with no center-line, or just a single strip that makes a circuit! At the least, you'll be able to do an end-to-end testing and verify that the software pipeline is all properly functional. Of course, as the next-step, you'll want to create a more standard track, and compete at a \nmeetup\n nearest to you!\n\n\n\n\n\n\nGet help\n : Try to get some helping hands from a friend or two. Again, this helps immensely with building the track, because it is harder than it looks to build a two-line track on your own! Also, you can save on resources (and tapes) by using a \nribbon\n instead of tapes. They'll still need a bit of tapes to hold them, but you can reuse them and they can be laid down with a lot less effort (Although the wind, if you're working outside, might make it difficult to lay them down initially).", 
            "title": "Train an autopilot."
        }, 
        {
            "location": "/guide/train_autopilot/#train-an-autopilot-with-keras", 
            "text": "Now that you're able to drive your car reliably you can use Keras to train a\nneural network to drive like you. Here are the steps.", 
            "title": "Train an autopilot with Keras"
        }, 
        {
            "location": "/guide/train_autopilot/#collect-data", 
            "text": "Make sure you collect good data.    Practice driving around the track a couple times without recording data.  When you're confident you can drive 10 laps without mistake press  Start Recording  If you crash or run off the track press Stop Car immediately to stop recording. \nA little bad data won't affect your autopilot.   After you've collected 10-20 laps of good data (5-20k images) you can stop \nyour car with  Ctrl-c  in the ssh session for your car.  The data you've collected is in the data folder in the most recent tub folder.", 
            "title": "Collect Data"
        }, 
        {
            "location": "/guide/train_autopilot/#transfer-data-from-your-car-to-your-computer", 
            "text": "Since the Raspberry Pi is not very powerful, we need to transfer the data\nto a PC computer to train.  In a new terminal session on your host PC use rsync to copy your cars \nfolder from the raspberry pi.  rsync -r pi@ your_pi_ip_address :~/d2/data/  ~/d2/data/", 
            "title": "Transfer data from your car to your computer."
        }, 
        {
            "location": "/guide/train_autopilot/#train-a-model", 
            "text": "In the same terminal you can now run the training script on the latest tub by passing the path to that tub as an argument. You can optionally pass path masks, such as  ./data/*  or  ./data/tub_?_17-08-28  to gather multiple tubs. For example:    python ~/d2/manage.py train --tub  tub folder names comma separated  --model ./models/mypilot  Optionally you can pass no arguments for the tub, and then all tubs will be used in the default data dir.   python ~/d2/manage.py train --model ~/d2/models/mypilot   Now you can use rsync again to move your pilot back to your car.    rsync -r ~/d2/models/ pi@ your_ip_address :~/d2/models/   Now you can start your car again and pass it your model to drive.   python manage.py drive --model ~/d2/models/mypilot", 
            "title": "Train a model"
        }, 
        {
            "location": "/guide/train_autopilot/#training-tips", 
            "text": "Mode   Pilot : Congratulations on getting it this far. The first thing to note after running the command above, is to look at the options in the Mode   Pilot menu. It can be pretty confusing. So here's what the different options mean:  a.  User  : As you guessed, this is where you are in control of both the steering and throttle control.  b.  Local Angle  : Not too obvious, but this is where the trained model (mypilot from above) controls the steering. The  Local  refers to the trained model which is locally hosted on the raspberry-pi.  c.  Local Pilot  : This is where the trained model (mypilot) assumes control of both the steering and the throttle. As of now, it's purportedly not very reliable.  Be sure to also check out the  Max Throttle  and  Throttle Mode  options, and play around with a few settings. Can help with training quite a lot.     Build a Simple Track  : This isn't very well-documented, but the car should (theoretically) be able to train against any kind of track. To start off with, it might not be necessary to build a two-lane track with a striped center-lane. Try with a single lane with no center-line, or just a single strip that makes a circuit! At the least, you'll be able to do an end-to-end testing and verify that the software pipeline is all properly functional. Of course, as the next-step, you'll want to create a more standard track, and compete at a  meetup  nearest to you!    Get help  : Try to get some helping hands from a friend or two. Again, this helps immensely with building the track, because it is harder than it looks to build a two-line track on your own! Also, you can save on resources (and tapes) by using a  ribbon  instead of tapes. They'll still need a bit of tapes to hold them, but you can reuse them and they can be laid down with a lot less effort (Although the wind, if you're working outside, might make it difficult to lay them down initially).", 
            "title": "Training Tips:"
        }, 
        {
            "location": "/guide/simulator/", 
            "text": "Donkey Simulator\n\n\nExperiment with training a donkey car to drive in simulation. This simulator is built on the the Unity game platform, uses their internal physics and graphics, and connects to a donkey Python process to use our trained model to control the simulated Donkey.\n\n\nDownload the Simulator\n\n\nYou will need a specific build per platform:\n\n\n\n\nUbuntu 16.04 \ndownload\n\n\nMac 10.10.5+ \ndownload\n\n\nWindows 7+ \ndownload\n\n\n\n\nExtract this compressed file. It will create a folder containing an executable. Double click that executable to launch the simulator.\n\n\nExtra Mac Steps\n\n\nIf logs are not being generated you are probably running a version of OS X that sandboxes untrusted applications. This prevents the simulator writing to disk. To resolve this, move the executable within the Applications folder.\n\n\nRecorded Data\n\n\nThis simulator can create log data in the donkey tub format. This is stored in the \nlog\n dir at the root of the folder next to the executable. On the mac you will need to browse the package contents to see this folder. If this folder is missing, no data will be recorded.\n\n\nYou can choose two different scenes.\n\n\nGenerated Road Scene\n\n\nThe purpose of this is to create a randomly generated road so that you can have miles of curves on different road surfaces. You can train on one road and test on something similar, or a totally different surface.\n\n\nWarehouse Scene\n\n\nThe purpose of this is to create a specific track that is somewhat similar to an actual course in use as the primary track for the Oakland DIYRobocars Meetup.\n\n\n\n\nMenu Options:\n\n\nJoystick/Keyboard No Rec\n\n\nDrive the donkey with a joystick or keyboard. I used a PS2 Joystick and a PS3 Joystick. Keyboard controls use arrow keys to steer. In this mode, no data is recorded.\n\n\n\n\nNote: Keyboard data produces steering information that is stepped (ie. -1, 0, +1) and may be difficult to train with. See below for joystick setup.\n\n\n\n\nJoystick/Keyboard w Rec\n\n\nDrive the donkey with a joystick or keyboard. In this mode, data is stored in the tub donkey format.\n\n\nAuto Drive No Rec\n\n\nThis uses path information to guide the donkey down the track. It uses a PID controller to steer, so there is some oscillation. In this mode, no data is stored.\n\n\nAuto Drive w Rec\n\n\nThis uses path information to guide the donkey down the track. It uses a PID controller to steer, so there is some oscillation. In this mode, data is stored in the tub donkey format.\n\n\nNext Track\n\n\nIn the generated road scene, this will switch out the road surface and track width.\n\n\nRegen Track\n\n\nUse the current surface type, but generate a new random path and road.\n\n\n\n\nPID Controls\n\n\nMax Speed\n\n\nThis setting determines the target speed during the PID auto drive. It will also affect the speed when driving by keyboard controls (not recommended).\n\n\nProp\n\n\nThis is short for proportional. This is the P part of PID that attempts to adjust steering back to the path in proportion to the deviation.\n\n\nDiff\n\n\nThis is the D part of PID that attempts to limit steering back to the path as derivative to the trend of deviation, designed to limit overshoot.\n\n\nMax Steering\n\n\n\n\nNote - Max Steering is an important adjustment. This affects categorical training quite strongly. As the steering data is normalized when written, and multiplies after coming from Python, this angle should remain constant over training and simulation. Take care when changing this value. And separate data and models by max steering setting.\n\n\n\n\nMax steering can only be adjusted when using \nAuto Drive No Rec\n. It will also affect joystick and keyboard steering range, and should be saved and reloaded for you.\n\n\nThe default categorical model has 16 bins, or classes. And so, with a max steering of +-16, each bin will represent 2 degrees. It is helpful to graph the model training vs the example data to get and intuition about how it fits the data.\n\n\n\n\nTypical Use\n\n\n\n\nStart simulator\n\n\nDouble check that \nlog\n dir exists and is empty\n\n\nStart scene of your choice\n\n\nHit \nAuto Drive w Rec\n button\n\n\nVary the Max Speed, Prop, and Diff sliders to obtain a variety of driving styles\n\n\nWait 10-15 minutes until you have recorded 10K+ frames of data.\n\n\nHit the \nStop\n button\n\n\nHit the \nExit\n button\n\n\nMove the \nlog\n dir to the \n~/d2/data/\n dir where you normally put tub data. This will create a \n~/d2/data/log\n path.\n\n\nTrain as usual. \n\n\n\n\n\n\nNote: I had problems w default categorical model. Linear model worked better for me.\n\n\n\n\npython manage.py train --tub=data/log --model=models/mypilot\n\n\n\n\n\n\nStart the simulator server. \n\n\n\n\ndonkey sim --model=models/mypilot\n\n\n\n\nWait to see \nwsgi starting up on http://0.0.0.0:9090\n\n\n\n\nEnter the scene of your choice in the simulator\n\n\nHit the button \nNN Steering w Websockets\n\n\nYour donkey should begin to move. You should see in the upper left two values for incoming steering and throttle.\n\n\n\n\n\n\nJoystick Setup\n\n\nKeyboard input provides a poor learning signal. I recommend using the joystick to provide manual driving data. \n\n\nLinux Joystick Setup\n\n\nUnity on Linux uses the SDL library to see your joystick. And in particular the GamePad API. This is not setup by default. I needed to do these steps:\n\n\ngit clone https://github.com/Grumbel/sdl-jstest\n\nsudo apt-get install cmake\nsudo apt-get install libsdl1.2-dev\nsudo apt-get install libsdl2-dev\nsudo apt-get install libncurses5-dev\ncd sdl-jstest\nmkdir build\ncd build\ncmake ..\nmake install\n\n\n./sdl2-jstest -l\n\n\n\n\nLook for:\nJoystick GUID: 030000004f04000008b1000000010000\n\n\nThe GUID will be different depending on your device.\n\n\nThen open:\nhttps://github.com/gabomdq/SDL_GameControllerDB/blob/master/gamecontrollerdb.txt\n\n\nand look for your GUID in Linux section. One line is for one device type. Now modify your environment to specify information for your device:\n\n\nsudo -H gedit /etc/environment\n\n\n\n\nadd the line SDL_GAMECONTROLLERCONFIG=, make sure to add the quotes at begin and end. ie.\n\n\nSDL_GAMECONTROLLERCONFIG=\"030000004f04000008b1000000010000, ... and the rest of the long line copied from gamecontrollerdb\"\n\n\n\n\nreboot\n\n\nstart sim\n\n\nchoose drive w joystick\n\n\nmove sticks\n\n\ndo happy dance", 
            "title": "Donkey Simulator."
        }, 
        {
            "location": "/guide/simulator/#donkey-simulator", 
            "text": "Experiment with training a donkey car to drive in simulation. This simulator is built on the the Unity game platform, uses their internal physics and graphics, and connects to a donkey Python process to use our trained model to control the simulated Donkey.", 
            "title": "Donkey Simulator"
        }, 
        {
            "location": "/guide/simulator/#download-the-simulator", 
            "text": "You will need a specific build per platform:   Ubuntu 16.04  download  Mac 10.10.5+  download  Windows 7+  download   Extract this compressed file. It will create a folder containing an executable. Double click that executable to launch the simulator.", 
            "title": "Download the Simulator"
        }, 
        {
            "location": "/guide/simulator/#extra-mac-steps", 
            "text": "If logs are not being generated you are probably running a version of OS X that sandboxes untrusted applications. This prevents the simulator writing to disk. To resolve this, move the executable within the Applications folder.", 
            "title": "Extra Mac Steps"
        }, 
        {
            "location": "/guide/simulator/#recorded-data", 
            "text": "This simulator can create log data in the donkey tub format. This is stored in the  log  dir at the root of the folder next to the executable. On the mac you will need to browse the package contents to see this folder. If this folder is missing, no data will be recorded.  You can choose two different scenes.", 
            "title": "Recorded Data"
        }, 
        {
            "location": "/guide/simulator/#generated-road-scene", 
            "text": "The purpose of this is to create a randomly generated road so that you can have miles of curves on different road surfaces. You can train on one road and test on something similar, or a totally different surface.", 
            "title": "Generated Road Scene"
        }, 
        {
            "location": "/guide/simulator/#warehouse-scene", 
            "text": "The purpose of this is to create a specific track that is somewhat similar to an actual course in use as the primary track for the Oakland DIYRobocars Meetup.", 
            "title": "Warehouse Scene"
        }, 
        {
            "location": "/guide/simulator/#menu-options", 
            "text": "", 
            "title": "Menu Options:"
        }, 
        {
            "location": "/guide/simulator/#joystickkeyboard-no-rec", 
            "text": "Drive the donkey with a joystick or keyboard. I used a PS2 Joystick and a PS3 Joystick. Keyboard controls use arrow keys to steer. In this mode, no data is recorded.   Note: Keyboard data produces steering information that is stepped (ie. -1, 0, +1) and may be difficult to train with. See below for joystick setup.", 
            "title": "Joystick/Keyboard No Rec"
        }, 
        {
            "location": "/guide/simulator/#joystickkeyboard-w-rec", 
            "text": "Drive the donkey with a joystick or keyboard. In this mode, data is stored in the tub donkey format.", 
            "title": "Joystick/Keyboard w Rec"
        }, 
        {
            "location": "/guide/simulator/#auto-drive-no-rec", 
            "text": "This uses path information to guide the donkey down the track. It uses a PID controller to steer, so there is some oscillation. In this mode, no data is stored.", 
            "title": "Auto Drive No Rec"
        }, 
        {
            "location": "/guide/simulator/#auto-drive-w-rec", 
            "text": "This uses path information to guide the donkey down the track. It uses a PID controller to steer, so there is some oscillation. In this mode, data is stored in the tub donkey format.", 
            "title": "Auto Drive w Rec"
        }, 
        {
            "location": "/guide/simulator/#next-track", 
            "text": "In the generated road scene, this will switch out the road surface and track width.", 
            "title": "Next Track"
        }, 
        {
            "location": "/guide/simulator/#regen-track", 
            "text": "Use the current surface type, but generate a new random path and road.", 
            "title": "Regen Track"
        }, 
        {
            "location": "/guide/simulator/#pid-controls", 
            "text": "", 
            "title": "PID Controls"
        }, 
        {
            "location": "/guide/simulator/#max-speed", 
            "text": "This setting determines the target speed during the PID auto drive. It will also affect the speed when driving by keyboard controls (not recommended).", 
            "title": "Max Speed"
        }, 
        {
            "location": "/guide/simulator/#prop", 
            "text": "This is short for proportional. This is the P part of PID that attempts to adjust steering back to the path in proportion to the deviation.", 
            "title": "Prop"
        }, 
        {
            "location": "/guide/simulator/#diff", 
            "text": "This is the D part of PID that attempts to limit steering back to the path as derivative to the trend of deviation, designed to limit overshoot.", 
            "title": "Diff"
        }, 
        {
            "location": "/guide/simulator/#max-steering", 
            "text": "Note - Max Steering is an important adjustment. This affects categorical training quite strongly. As the steering data is normalized when written, and multiplies after coming from Python, this angle should remain constant over training and simulation. Take care when changing this value. And separate data and models by max steering setting.   Max steering can only be adjusted when using  Auto Drive No Rec . It will also affect joystick and keyboard steering range, and should be saved and reloaded for you.  The default categorical model has 16 bins, or classes. And so, with a max steering of +-16, each bin will represent 2 degrees. It is helpful to graph the model training vs the example data to get and intuition about how it fits the data.", 
            "title": "Max Steering"
        }, 
        {
            "location": "/guide/simulator/#typical-use", 
            "text": "Start simulator  Double check that  log  dir exists and is empty  Start scene of your choice  Hit  Auto Drive w Rec  button  Vary the Max Speed, Prop, and Diff sliders to obtain a variety of driving styles  Wait 10-15 minutes until you have recorded 10K+ frames of data.  Hit the  Stop  button  Hit the  Exit  button  Move the  log  dir to the  ~/d2/data/  dir where you normally put tub data. This will create a  ~/d2/data/log  path.  Train as usual.     Note: I had problems w default categorical model. Linear model worked better for me.   python manage.py train --tub=data/log --model=models/mypilot   Start the simulator server.    donkey sim --model=models/mypilot  Wait to see  wsgi starting up on http://0.0.0.0:9090   Enter the scene of your choice in the simulator  Hit the button  NN Steering w Websockets  Your donkey should begin to move. You should see in the upper left two values for incoming steering and throttle.", 
            "title": "Typical Use"
        }, 
        {
            "location": "/guide/simulator/#joystick-setup", 
            "text": "Keyboard input provides a poor learning signal. I recommend using the joystick to provide manual driving data.", 
            "title": "Joystick Setup"
        }, 
        {
            "location": "/guide/simulator/#linux-joystick-setup", 
            "text": "Unity on Linux uses the SDL library to see your joystick. And in particular the GamePad API. This is not setup by default. I needed to do these steps:  git clone https://github.com/Grumbel/sdl-jstest\n\nsudo apt-get install cmake\nsudo apt-get install libsdl1.2-dev\nsudo apt-get install libsdl2-dev\nsudo apt-get install libncurses5-dev\ncd sdl-jstest\nmkdir build\ncd build\ncmake ..\nmake install\n\n\n./sdl2-jstest -l  Look for:\nJoystick GUID: 030000004f04000008b1000000010000  The GUID will be different depending on your device.  Then open:\nhttps://github.com/gabomdq/SDL_GameControllerDB/blob/master/gamecontrollerdb.txt  and look for your GUID in Linux section. One line is for one device type. Now modify your environment to specify information for your device:  sudo -H gedit /etc/environment  add the line SDL_GAMECONTROLLERCONFIG=, make sure to add the quotes at begin and end. ie.  SDL_GAMECONTROLLERCONFIG=\"030000004f04000008b1000000010000, ... and the rest of the long line copied from gamecontrollerdb\"   reboot  start sim  choose drive w joystick  move sticks  do happy dance", 
            "title": "Linux Joystick Setup"
        }, 
        {
            "location": "/parts/about/", 
            "text": "What is a Part\n\n\nA part Python class that wraps a functional component of a vehicle. \nThese include: \n\n Sensors - Cameras, Lidar, Odometers, GPS ...\n\n Actuators - Motor Controllers\n\n Pilots - Lane Detectors, Behavioral Cloning models, ...\n\n Controllers - Web based or Bluetooth.\n* Stores - Tub, or a way to save data. \n\n\nHere is an example how to use the PiCamera part to publish an image in the\n'cam/img' channel on every drive loop.\n\n\nV = dk.Vehicle()\n\n#initialize the camera part\ncam = PiCamera()\n\n#add the part to the vehicle.\nV.add(cam, outputs=['cam/img'])\n\nV.start()\n\n\n\n\nAnatomy of a Part\n\n\nAll parts share a common structure so that they can all be run by the vehicles\ndrive loop. Here is an example of a part that will accept a number, multiply \nit by a random number and return the result.\n\n\nimport random \n\nclass RandPercent:\n    def run(self, x):\n        return x * random.random()\n\n\n\n\nNow to add this to a vehicle:\n\n\nV = dk.Vehicle()\n\n#initialize the channel value\nV.mem['const'] = 4\n\n#add the part to read and write to the same channel.\nV.add(RandPercent, inputs=['const'], outputs=['cost'])\n\nV.start(max_loops=5)\n\n\n\n\nThreaded Parts\n\n\nFor a vehicle to perform well the drive loop must execute 10-30 times per\nsecond so slow parts should be threaded to avoid holding up the drive loop.\n\n\nA threaded part needs to define the function that runs in the separate thread\nand the function to call that will return the most recent values quickly. \n\n\nHere's an example how to make the RandPercent part threaded if the run\nfunction too a second to complete. \n\n\nimport random \nimport time\n\nclass RandPercent:\n    self.in = 0.\n    self.out = 0.\n    def run(self, x):\n        return x * random.random()\n        time.sleep(1)\n\n    def update(self):\n        #the funtion run in it's own thread\n        while True:\n            self.out = self.run(self.in)\n\n    def run_threaded(self, x):\n        self.in = x\n        return self.out\n\n\n\n\n\n\n\npart.run\n : function used to run the part\n\n\npart.run_threaded\n : drive loop function run if part is threaded.\n\n\npart.update\n : threaded function  \n\n\npart.shutdown", 
            "title": "About"
        }, 
        {
            "location": "/parts/about/#what-is-a-part", 
            "text": "A part Python class that wraps a functional component of a vehicle. \nThese include:   Sensors - Cameras, Lidar, Odometers, GPS ...  Actuators - Motor Controllers  Pilots - Lane Detectors, Behavioral Cloning models, ...  Controllers - Web based or Bluetooth.\n* Stores - Tub, or a way to save data.   Here is an example how to use the PiCamera part to publish an image in the\n'cam/img' channel on every drive loop.  V = dk.Vehicle()\n\n#initialize the camera part\ncam = PiCamera()\n\n#add the part to the vehicle.\nV.add(cam, outputs=['cam/img'])\n\nV.start()", 
            "title": "What is a Part"
        }, 
        {
            "location": "/parts/about/#anatomy-of-a-part", 
            "text": "All parts share a common structure so that they can all be run by the vehicles\ndrive loop. Here is an example of a part that will accept a number, multiply \nit by a random number and return the result.  import random \n\nclass RandPercent:\n    def run(self, x):\n        return x * random.random()  Now to add this to a vehicle:  V = dk.Vehicle()\n\n#initialize the channel value\nV.mem['const'] = 4\n\n#add the part to read and write to the same channel.\nV.add(RandPercent, inputs=['const'], outputs=['cost'])\n\nV.start(max_loops=5)", 
            "title": "Anatomy of a Part"
        }, 
        {
            "location": "/parts/about/#threaded-parts", 
            "text": "For a vehicle to perform well the drive loop must execute 10-30 times per\nsecond so slow parts should be threaded to avoid holding up the drive loop.  A threaded part needs to define the function that runs in the separate thread\nand the function to call that will return the most recent values quickly.   Here's an example how to make the RandPercent part threaded if the run\nfunction too a second to complete.   import random \nimport time\n\nclass RandPercent:\n    self.in = 0.\n    self.out = 0.\n    def run(self, x):\n        return x * random.random()\n        time.sleep(1)\n\n    def update(self):\n        #the funtion run in it's own thread\n        while True:\n            self.out = self.run(self.in)\n\n    def run_threaded(self, x):\n        self.in = x\n        return self.out   part.run  : function used to run the part  part.run_threaded  : drive loop function run if part is threaded.  part.update  : threaded function    part.shutdown", 
            "title": "Threaded Parts"
        }, 
        {
            "location": "/parts/actuators/", 
            "text": "", 
            "title": "Actuators"
        }, 
        {
            "location": "/parts/controllers/", 
            "text": "Controller Parts\n\n\nLocal Web Controller\n\n\nThe default controller to drive the car with your phone or browser. This has a web live preview of camera. Control options include:\n\n\n\n\nA virtual joystick\n\n\nThe tilt, when using a mobile device with supported accelerometer\n\n\nA physical joystick using the web adapter. Support varies per browser, OS, and joystick combination.\n\n\n\n\nPhysical Joystick Controller\n\n\nThe default web controller may be replaced with a one line change to use a physical joystick part for input. This uses the OS device /dev/input/js0 by default. In theory, any joystick device that the OS mounts like this can be used. In practice, the behavior will change depending on the model of joystick ( Sony, or knockoff ), or XBox controller and the Bluetooth driver used to support it. The default code has been written and tested with a \nSony brand PS3 Sixaxis controller\n. Other controllers may work, but will require alternative Bluetooth installs, and tweaks to the software for correct axis and buttons.\n\n\nThese can be used plugged in with a USB cable - but the default code and os driver has a bug polling this configuration. It's been much more stable, and convenient, to setup Bluetooth for a wireless, responsive control.\n\n\nChange to config.py or run with --js\n\n\npython manage.py drive --js\n\n\n\n\nWill enable driving with the joystick. This disables the live preview of the camera and the web page features. If you modify config.py to make USE_JOYSTICK_AS_DEFAULT = True, then you do not need to run with the --js.\n\n\nBluetooth Setup\n\n\nFollow \nthis guide\n. You can ignore steps past the 'Accessing the SixAxis from Python' section. I will include steps here in case the link becomes stale.\n\n\nsudo apt-get install bluetooth libbluetooth3 libusb-dev\nsudo systemctl enable bluetooth.service\nsudo usermod -G bluetooth -a pi\n\n\n\n\nReboot after changing the user group.\n\n\nPlug in the PS3 with USB cable. Hit center PS logo button. Get and build the command line pairing tool. Run it:\n\n\nwget http://www.pabr.org/sixlinux/sixpair.c\ngcc -o sixpair sixpair.c -lusb\nsudo ./sixpair\n\n\n\n\nUse bluetoothctl to pair\n\n\nbluetoothctl\nagent on\ndevices\ntrust \nMAC ADDRESS\n\ndefault-agent\nquit\n\n\n\n\nUnplug USB cable. Hit center PS logo button.\n\n\nTo test that the Bluetooth PS3 remote is working, verify that /dev/input/js0 exists.\n\n\nls /dev/input/js0\n\n\n\n\nCharging PS3 Sixaxis Joystick\n\n\nFor some reason, this joystick doesn't like to charge in a powered USB port that doesn't have an active Bluetooth control and OS driver. This means a phone type USB charger will not work, and charging from a Windows machine doesn't work either.\n\n\nYou can always charge from the Raspberry Pi, though.  Just plug the joystick into the Pi and power the Pi using a charger or your PC, and you are good to go.\n\n\nNew Battery for PS3 Sixaxis Joystick\n\n\nSometimes these controllers can be quite old. Here's a link to a \nnew battery\n. Be careful when taking off the cover. Remove 5 screws. There's a tab on the top half between the hand grips. You'll want to split/open it from the front and try pulling the bottom forward as you do, or you'll break the tab off as I did.", 
            "title": "Controllers"
        }, 
        {
            "location": "/parts/controllers/#controller-parts", 
            "text": "", 
            "title": "Controller Parts"
        }, 
        {
            "location": "/parts/controllers/#local-web-controller", 
            "text": "The default controller to drive the car with your phone or browser. This has a web live preview of camera. Control options include:   A virtual joystick  The tilt, when using a mobile device with supported accelerometer  A physical joystick using the web adapter. Support varies per browser, OS, and joystick combination.", 
            "title": "Local Web Controller"
        }, 
        {
            "location": "/parts/controllers/#physical-joystick-controller", 
            "text": "The default web controller may be replaced with a one line change to use a physical joystick part for input. This uses the OS device /dev/input/js0 by default. In theory, any joystick device that the OS mounts like this can be used. In practice, the behavior will change depending on the model of joystick ( Sony, or knockoff ), or XBox controller and the Bluetooth driver used to support it. The default code has been written and tested with a  Sony brand PS3 Sixaxis controller . Other controllers may work, but will require alternative Bluetooth installs, and tweaks to the software for correct axis and buttons.  These can be used plugged in with a USB cable - but the default code and os driver has a bug polling this configuration. It's been much more stable, and convenient, to setup Bluetooth for a wireless, responsive control.", 
            "title": "Physical Joystick Controller"
        }, 
        {
            "location": "/parts/controllers/#change-to-configpy-or-run-with-js", 
            "text": "python manage.py drive --js  Will enable driving with the joystick. This disables the live preview of the camera and the web page features. If you modify config.py to make USE_JOYSTICK_AS_DEFAULT = True, then you do not need to run with the --js.", 
            "title": "Change to config.py or run with --js"
        }, 
        {
            "location": "/parts/controllers/#bluetooth-setup", 
            "text": "Follow  this guide . You can ignore steps past the 'Accessing the SixAxis from Python' section. I will include steps here in case the link becomes stale.  sudo apt-get install bluetooth libbluetooth3 libusb-dev\nsudo systemctl enable bluetooth.service\nsudo usermod -G bluetooth -a pi  Reboot after changing the user group.  Plug in the PS3 with USB cable. Hit center PS logo button. Get and build the command line pairing tool. Run it:  wget http://www.pabr.org/sixlinux/sixpair.c\ngcc -o sixpair sixpair.c -lusb\nsudo ./sixpair  Use bluetoothctl to pair  bluetoothctl\nagent on\ndevices\ntrust  MAC ADDRESS \ndefault-agent\nquit  Unplug USB cable. Hit center PS logo button.  To test that the Bluetooth PS3 remote is working, verify that /dev/input/js0 exists.  ls /dev/input/js0", 
            "title": "Bluetooth Setup"
        }, 
        {
            "location": "/parts/controllers/#charging-ps3-sixaxis-joystick", 
            "text": "For some reason, this joystick doesn't like to charge in a powered USB port that doesn't have an active Bluetooth control and OS driver. This means a phone type USB charger will not work, and charging from a Windows machine doesn't work either.  You can always charge from the Raspberry Pi, though.  Just plug the joystick into the Pi and power the Pi using a charger or your PC, and you are good to go.", 
            "title": "Charging PS3 Sixaxis Joystick"
        }, 
        {
            "location": "/parts/controllers/#new-battery-for-ps3-sixaxis-joystick", 
            "text": "Sometimes these controllers can be quite old. Here's a link to a  new battery . Be careful when taking off the cover. Remove 5 screws. There's a tab on the top half between the hand grips. You'll want to split/open it from the front and try pulling the bottom forward as you do, or you'll break the tab off as I did.", 
            "title": "New Battery for PS3 Sixaxis Joystick"
        }, 
        {
            "location": "/parts/stores/", 
            "text": "Stores\n\n\nStores are parts that record and replay vehicle data produced by other parts. \n\n\nTub\n\n\nThis is the standard donkey data store and it is modeled after the ROSBAG.\n\n\n\n\nTODO: The structure of the Tub part is not ideal and should be changed.\n\n\n\n\ntypes should not need to be specified and could be inspected and saved \non the first loop.\n\n\n\n\n\n\nExample creation \n\n\nimport donkey as dk\n\nT = dk.parts.Tub(path, inputs, types)\n\n\n\n\n\nAccepted Types\n\n\n\n\nfloat\n - saved as record\n\n\nint\n - saved as record", 
            "title": "Stores"
        }, 
        {
            "location": "/parts/stores/#stores", 
            "text": "Stores are parts that record and replay vehicle data produced by other parts.", 
            "title": "Stores"
        }, 
        {
            "location": "/parts/stores/#tub", 
            "text": "This is the standard donkey data store and it is modeled after the ROSBAG.   TODO: The structure of the Tub part is not ideal and should be changed.   types should not need to be specified and could be inspected and saved \non the first loop.    Example creation   import donkey as dk\n\nT = dk.parts.Tub(path, inputs, types)", 
            "title": "Tub"
        }, 
        {
            "location": "/parts/stores/#accepted-types", 
            "text": "float  - saved as record  int  - saved as record", 
            "title": "Accepted Types"
        }, 
        {
            "location": "/parts/imu/", 
            "text": "IMU\n\n\nIMUs or inertial measurement units are parts that sense the inertial forces on a robot. They vary depending on sensor, but may commonly include linear and rotational accelleration. They may sometimes include magnetometer to give global compasss facing dir. Frequently temperature is available from these as it affects their sensitivity.\n\n\nMPU6050\n\n\nThis is a cheap, small, and moderately precise imu. Commonly available at \nAmazon\n.\n\n\n\n\nTypically uses the I2C interface and can be chained off the default PWM PCA9685 board. This configuration will also provide power.\n\n\nOutputs acceleration X, Y, Z, Gyroscope X, Y, Z, and temperature.\n\n\nChip built-in 16bit AD converter, 16bit data output\n\n\nGyroscopes range: +/- 250 500 1000 2000 degree/sec\n\n\nAcceleration range: \u00b12 \u00b14 \u00b18 \u00b116g\n\n\n\n\nSoftware Setup\n\n\nInstall smbus:\n\n\nfrom package:\n\n\n sudo apt install python3-smbus\n\n\n\n\nor from source:\n\n\nsudo apt-get install i2c-tools libi2c-dev python-dev python3-dev\ngit clone https://github.com/pimoroni/py-smbus.git\ncd py-smbus/library\npython setup.py build\nsudo python setup.py install\n\n\n\n\nInstall pip lib for mpu6050\n\n\npip install mpu6050-raspberrypi", 
            "title": "IMU"
        }, 
        {
            "location": "/parts/imu/#imu", 
            "text": "IMUs or inertial measurement units are parts that sense the inertial forces on a robot. They vary depending on sensor, but may commonly include linear and rotational accelleration. They may sometimes include magnetometer to give global compasss facing dir. Frequently temperature is available from these as it affects their sensitivity.", 
            "title": "IMU"
        }, 
        {
            "location": "/parts/imu/#mpu6050", 
            "text": "This is a cheap, small, and moderately precise imu. Commonly available at  Amazon .   Typically uses the I2C interface and can be chained off the default PWM PCA9685 board. This configuration will also provide power.  Outputs acceleration X, Y, Z, Gyroscope X, Y, Z, and temperature.  Chip built-in 16bit AD converter, 16bit data output  Gyroscopes range: +/- 250 500 1000 2000 degree/sec  Acceleration range: \u00b12 \u00b14 \u00b18 \u00b116g", 
            "title": "MPU6050"
        }, 
        {
            "location": "/parts/imu/#software-setup", 
            "text": "Install smbus:  from package:   sudo apt install python3-smbus  or from source:  sudo apt-get install i2c-tools libi2c-dev python-dev python3-dev\ngit clone https://github.com/pimoroni/py-smbus.git\ncd py-smbus/library\npython setup.py build\nsudo python setup.py install  Install pip lib for mpu6050  pip install mpu6050-raspberrypi", 
            "title": "Software Setup"
        }, 
        {
            "location": "/utility/donkey/", 
            "text": "Donkey Command-line Utilities\n\n\nThe \ndonkey\n command is created when you install the donkeycar Python package. This is a Python script that adds some important functionality. The operations here are vehicle independent, and should work on any hardware configuration.\n\n\nCreate Car\n\n\nThis command creates a new dir which will contain the files needed to run and train your robot.\n\n\nUsage:\n\n\ndonkey createcar --path \ndir\n [--overwrite] [--template \ndonkey2\n]\n\n\n\n\n\n\nThis command may be run from any dir\n\n\nRun on the host computer or the robot\n\n\nIt uses the \n--path\n as the destination dir to create. If \n.py\n files exist there, it will not overwrite them, unless the optional \n--overwrite\n is used. \n\n\nThe optional \n--template\n will specify the template file to start from. For a list of templates, see the \ndonkeycar/templates\n dir\n\n\n\n\nFind Car\n\n\nThis command attempts to locate your car on the local network using nmap.\n\n\nUsage:\n\n\ndonkey findcar\n\n\n\n\n\n\nRun on the host computer\n\n\nPrints the host computer IP address and the car IP address if found\n\n\nRequires the nmap utility:\n\n\n\n\nsudo apt install nmap\n\n\n\n\nCalibrate Car\n\n\nThis command allows you to manually enter values to interactively set the PWM values and experiment with how your robot responds.\nSee also \nmore information.\n\n\nUsage:\n\n\ndonkey calibrate --channel \n0-15 channel id\n\n\n\n\n\n\n\nRun on the host computer\n\n\nOpens the PWM channel specified by \n--channel\n\n\nType integer values to specify PWM values and hit enter\n\n\nHit \nCtrl + C\n to exit\n\n\n\n\nClean data in Tub\n\n\nOpens a web server to delete bad data from a tub.\n\n\nUsage:\n\n\ndonkey tubclean \nfolder containing tubs\n\n\n\n\n\n\n\nRun on pi or host computer.\n\n\nOpens the web server to delete bad data.\n\n\nHit \nCtrl + C\n to exit\n\n\n\n\nMake Movie from Tub\n\n\nThis command allows you to create a movie file from the images in a Tub.\n\n\nUsage:\n\n\ndonkey makemovie \ntub_path\n [--out=\ntub_movie.mp4\n] [--config=\nconfig.py\n]\n\n\n\n\n\n\nRun on the host computer or the robot\n\n\nUses the image records from \n--tub\n dir path given\n\n\nCreates a movie given by \n--out\n. Codec is inferred from file extension. Default: \ntub_movie.mp4\n\n\nOptional argument to specify a different \nconfig.py\n other than default: \nconfig.py\n\n\n\n\nCheck Tub\n\n\nThis command allows you to see how many records are contained in any/all tubs. It will also open each record and ensure that the data is readable and intact. If not, it will allow you to remove corrupt records.\n\n\nUsage:\n\n\ndonkey tubcheck \ntub_path\n [--fix]\n\n\n\n\n\n\nRun on the host computer or the robot\n\n\nIt will print summary of record count and channels recorded for each tub\n\n\nIt will print the records that throw an exception while reading\n\n\nThe optional \n--fix\n will delete records that have problems\n\n\n\n\nHistogram\n\n\nThis command will show a pop-up window showing the histogram of record values in a given tub.\n\n\nUsage:\n\n\ndonkey tubhist \ntub_path\n --rec=\nuser/angle\n\n\n\n\n\n\n\n\n\nRun on the host computer\n\n\n\n\n\n\nWhen the \n--tub\n is omitted, it will check all tubs in the default data dir\n\n\n\n\n\n\nPlot Predictions\n\n\nThis command allows you plot steering and throttle against predictions coming from a trained model.\n\n\nUsage:\n\n\ndonkey tubplot \ntub_path\n [--model=\nmodel_path\n]\n\n\n\n\n\n\nThis command may be run from \n~/d2\n dir\n\n\nRun on the host computer\n\n\nWill show a pop-up window showing the plot of steering values in a given tub compared to NN predictions from the trained model\n\n\nWhen the \n--tub\n is omitted, it will check all tubs in the default data dir\n\n\n\n\nSimulation Server\n\n\nThis command allows you serve steering and throttle controls to a simulated vehicle using the \nDonkey Simulator\n.\n\n\nUsage:\n\n\ndonkey sim --model=\nmodel_path\n [--type=\nlinear|categorical\n] [--top_speed=\nspeed\n] [--config=\nconfig.py\n]\n\n\n\n\n\n\nThis command may be run from \n~/d2\n dir\n\n\nRun on the host computer\n\n\nUses the model to make predictions based on images and telemetry from the simulator\n\n\n--type\n can specify whether the model needs angle output to be treated as categorical\n\n\nTop speed can be modified to ascertain stability at different goal speeds", 
            "title": "donkey"
        }, 
        {
            "location": "/utility/donkey/#donkey-command-line-utilities", 
            "text": "The  donkey  command is created when you install the donkeycar Python package. This is a Python script that adds some important functionality. The operations here are vehicle independent, and should work on any hardware configuration.", 
            "title": "Donkey Command-line Utilities"
        }, 
        {
            "location": "/utility/donkey/#create-car", 
            "text": "This command creates a new dir which will contain the files needed to run and train your robot.  Usage:  donkey createcar --path  dir  [--overwrite] [--template  donkey2 ]   This command may be run from any dir  Run on the host computer or the robot  It uses the  --path  as the destination dir to create. If  .py  files exist there, it will not overwrite them, unless the optional  --overwrite  is used.   The optional  --template  will specify the template file to start from. For a list of templates, see the  donkeycar/templates  dir", 
            "title": "Create Car"
        }, 
        {
            "location": "/utility/donkey/#find-car", 
            "text": "This command attempts to locate your car on the local network using nmap.  Usage:  donkey findcar   Run on the host computer  Prints the host computer IP address and the car IP address if found  Requires the nmap utility:   sudo apt install nmap", 
            "title": "Find Car"
        }, 
        {
            "location": "/utility/donkey/#calibrate-car", 
            "text": "This command allows you to manually enter values to interactively set the PWM values and experiment with how your robot responds.\nSee also  more information.  Usage:  donkey calibrate --channel  0-15 channel id    Run on the host computer  Opens the PWM channel specified by  --channel  Type integer values to specify PWM values and hit enter  Hit  Ctrl + C  to exit", 
            "title": "Calibrate Car"
        }, 
        {
            "location": "/utility/donkey/#clean-data-in-tub", 
            "text": "Opens a web server to delete bad data from a tub.  Usage:  donkey tubclean  folder containing tubs    Run on pi or host computer.  Opens the web server to delete bad data.  Hit  Ctrl + C  to exit", 
            "title": "Clean data in Tub"
        }, 
        {
            "location": "/utility/donkey/#make-movie-from-tub", 
            "text": "This command allows you to create a movie file from the images in a Tub.  Usage:  donkey makemovie  tub_path  [--out= tub_movie.mp4 ] [--config= config.py ]   Run on the host computer or the robot  Uses the image records from  --tub  dir path given  Creates a movie given by  --out . Codec is inferred from file extension. Default:  tub_movie.mp4  Optional argument to specify a different  config.py  other than default:  config.py", 
            "title": "Make Movie from Tub"
        }, 
        {
            "location": "/utility/donkey/#check-tub", 
            "text": "This command allows you to see how many records are contained in any/all tubs. It will also open each record and ensure that the data is readable and intact. If not, it will allow you to remove corrupt records.  Usage:  donkey tubcheck  tub_path  [--fix]   Run on the host computer or the robot  It will print summary of record count and channels recorded for each tub  It will print the records that throw an exception while reading  The optional  --fix  will delete records that have problems", 
            "title": "Check Tub"
        }, 
        {
            "location": "/utility/donkey/#histogram", 
            "text": "This command will show a pop-up window showing the histogram of record values in a given tub.  Usage:  donkey tubhist  tub_path  --rec= user/angle     Run on the host computer    When the  --tub  is omitted, it will check all tubs in the default data dir", 
            "title": "Histogram"
        }, 
        {
            "location": "/utility/donkey/#plot-predictions", 
            "text": "This command allows you plot steering and throttle against predictions coming from a trained model.  Usage:  donkey tubplot  tub_path  [--model= model_path ]   This command may be run from  ~/d2  dir  Run on the host computer  Will show a pop-up window showing the plot of steering values in a given tub compared to NN predictions from the trained model  When the  --tub  is omitted, it will check all tubs in the default data dir", 
            "title": "Plot Predictions"
        }, 
        {
            "location": "/utility/donkey/#simulation-server", 
            "text": "This command allows you serve steering and throttle controls to a simulated vehicle using the  Donkey Simulator .  Usage:  donkey sim --model= model_path  [--type= linear|categorical ] [--top_speed= speed ] [--config= config.py ]   This command may be run from  ~/d2  dir  Run on the host computer  Uses the model to make predictions based on images and telemetry from the simulator  --type  can specify whether the model needs angle output to be treated as categorical  Top speed can be modified to ascertain stability at different goal speeds", 
            "title": "Simulation Server"
        }, 
        {
            "location": "/supported_cars/", 
            "text": "Supported cars\n\n\nMagnet and HSP 94186\n\n\nThe magnet chassis was the first standard Donkey build.  However in many cases it may not be available.\n\n\n\n\nTry searching for both the Magnet and HSP 94186 on ebay, banggood, ali express etc.  \n\n\nThe HSP 94186 is the same as the Magnet and will work.  If you speak mandarin it is always available on Taobao.\n\n\nhttps://item.taobao.com/item.htm?spm=a230r.1.14.1.478a6da8CUjrQQ\nid=6004880592\nns=1\nabbucket=12#detail\n\n\nExceed Desert Monster, Short Course Truck, and Blaze\n\n\nThe Desert Monster, SCT and Blaze are made by the same manufacturer as the Magnet and has the same motor and ESC.  The chassis is slightly different so it requires an adapter and some extra hardware to work with the standard donkey platform.  With the adapters the camera placement will be identical to the Magnet and should be able to share models.\n\n\nIt is worth noting that the Desert Monster and SCT also has some nice characteristics including narrower, more road friendly tires and the Blaze has a slightly narrower stance which makes it less likely to hit things.  \n\n\n\nTu purchase one of these cars follow the following links:\n\n\n\n\nExceed Desert Monster \nBlue\n,  \nRed\n\n\nExceed Short Course Truck  \nBlue\n,  \nRed\n\n\nExceed Blaze \nHyper Blue\n, \nYellow\n\n\n\n\nTo assemble one of these you will need some additional parts than the standard build, these can be purchased as a kit on the donkey store at: Purchase: \nDonkey Store\n\n\n\n\n\n\n\n\nPart Description\n\n\nLink\n\n\nApproximate Cost\n\n\n\n\n\n\n\n\n\n\n3D printed Adapters\n\n\nFiles: \nthingiverse.com/thing:2260575\n\n\n$10\n\n\n\n\n\n\nChassis Clips\n\n\nAmazon\n\n\n$5\n\n\n\n\n\n\n\n\nTo assemble first remove the plastic cover and roll cage then unscrew the posts that hold up the cover and replace with the adapters.  \n\n\nVisual instructions to follow.\n\n\nTamaya TT-01 (Advanced Build)\n\n\n\n\nThe TT-01 is a new build that is a higher end version of the Donkey.  This is an advanced build and requires existing RC skills or the desire to learn them - along with some willingness to trial and error.  For first time builders we recommend the Magnet.  That said, it has some pros and cons that people should be aware of:\nPros:\n\n\n\n\nBetter kinematics and traction on smooth surfaces - basically this means it will corner better\n\n\nLarger build area for adding other sensors.  \n\n\nGlobally available with several clones.\n\n\n\n\nCons:\n\n\n\n\nAssembly required! - you will need to supply your own ESC, battery, servo, pinion gear and motor.\n\n\nNeeds to run on a smooth surface like a driveway or parking lot.   \n\n\nLarger size requires a larger 3D printer to print chassis, otherwise purchase at the Donkeystore.\n\n\nMore expensive\n\n\n\n\nIn addition to the standard donkey parts, Raspberry Pi etc, you will need to buy the following components.\n\n\n\n\n\n\n\n\nPart Description\n\n\nLink\n\n\nApproximate Cost\n\n\n\n\n\n\n\n\n\n\nTT-01 Clone Chassis\n\n\neBay\n other TT01s may be used\n\n\n$130\n\n\n\n\n\n\nESC\n\n\nhttps://hobbyking.com/en_us/hobbyking-x-car-45a-brushed-car-esc.html\n\n\n10.60\n\n\n\n\n\n\nBrushed Motor\n\n\nhttps://hobbyking.com/en_us/mabuchi-rs-540sh-6527-brushed-motor-90w.html\n\n\n$5\n\n\n\n\n\n\nSteering Servo\n\n\nhttps://hobbyking.com/en_us/hobbykingtm-hk15138-standard-analog-servo-4-3kg-0-17sec-38g.html\n\n\n$5\n\n\n\n\n\n\nBattery\n\n\nhttps://hobbyking.com/en_us/turnigy-5000mah-2s1p-20c-hardcase-pack-roar-approved-de-warehouse.html or similar 2S 5000 mAh battery\n\n\n$21\n\n\n\n\n\n\nPinion Gear\n\n\nhttps://www.amazon.com/gp/product/B001BHGIBG/ref=oh_aui_detailpage_o08_s00?ie=UTF8\npsc=1\n\n\n$7\n\n\n\n\n\n\nTT01 Plastics\n\n\nThingiverse: https://www.thingiverse.com/thing:2805287 or Donkeystore: https://squareup.com/store/donkeycar\n\n\n$50\n\n\n\n\n\n\n\n\nNote: purchasing from Hobbyking is tricky.  They can ship from multiple warehouses and it can be expensive and time consuming if shipping from one overseas.  You may need to buy an alternate component if one of the items above are not available in your local warehouse.\n\n\nIf You Want to Roll Your Own\n\n\nIt's totally possible to diverge from the main Donkey build, and still have a car that\ndrives well and is fun to work with. We've seen a large variety of cars in the various\nDonkey competitions around the world.\n\n\nHowever, when you want to diverge, there are several things you need to know, or you\nwill not be successful. There are many cost and quality trade-offs where the lower\ncost options simply won't work. We've already worked hard to find the cheapest\navailable options that will work, so you should not expect to choose other options to\nsave money. Rolling your own is more about learning, experimentation, and going to new\nand uncharged places.\n\n\nTo find out more about what you need, see \nRoll Your Own\n.", 
            "title": "Supported Cars"
        }, 
        {
            "location": "/supported_cars/#supported-cars", 
            "text": "", 
            "title": "Supported cars"
        }, 
        {
            "location": "/supported_cars/#magnet-and-hsp-94186", 
            "text": "The magnet chassis was the first standard Donkey build.  However in many cases it may not be available.   Try searching for both the Magnet and HSP 94186 on ebay, banggood, ali express etc.    The HSP 94186 is the same as the Magnet and will work.  If you speak mandarin it is always available on Taobao.  https://item.taobao.com/item.htm?spm=a230r.1.14.1.478a6da8CUjrQQ id=6004880592 ns=1 abbucket=12#detail", 
            "title": "Magnet and HSP 94186"
        }, 
        {
            "location": "/supported_cars/#exceed-desert-monster-short-course-truck-and-blaze", 
            "text": "The Desert Monster, SCT and Blaze are made by the same manufacturer as the Magnet and has the same motor and ESC.  The chassis is slightly different so it requires an adapter and some extra hardware to work with the standard donkey platform.  With the adapters the camera placement will be identical to the Magnet and should be able to share models.  It is worth noting that the Desert Monster and SCT also has some nice characteristics including narrower, more road friendly tires and the Blaze has a slightly narrower stance which makes it less likely to hit things.    \nTu purchase one of these cars follow the following links:   Exceed Desert Monster  Blue ,   Red  Exceed Short Course Truck   Blue ,   Red  Exceed Blaze  Hyper Blue ,  Yellow   To assemble one of these you will need some additional parts than the standard build, these can be purchased as a kit on the donkey store at: Purchase:  Donkey Store     Part Description  Link  Approximate Cost      3D printed Adapters  Files:  thingiverse.com/thing:2260575  $10    Chassis Clips  Amazon  $5     To assemble first remove the plastic cover and roll cage then unscrew the posts that hold up the cover and replace with the adapters.    Visual instructions to follow.", 
            "title": "Exceed Desert Monster, Short Course Truck, and Blaze"
        }, 
        {
            "location": "/supported_cars/#tamaya-tt-01-advanced-build", 
            "text": "The TT-01 is a new build that is a higher end version of the Donkey.  This is an advanced build and requires existing RC skills or the desire to learn them - along with some willingness to trial and error.  For first time builders we recommend the Magnet.  That said, it has some pros and cons that people should be aware of:\nPros:   Better kinematics and traction on smooth surfaces - basically this means it will corner better  Larger build area for adding other sensors.    Globally available with several clones.   Cons:   Assembly required! - you will need to supply your own ESC, battery, servo, pinion gear and motor.  Needs to run on a smooth surface like a driveway or parking lot.     Larger size requires a larger 3D printer to print chassis, otherwise purchase at the Donkeystore.  More expensive   In addition to the standard donkey parts, Raspberry Pi etc, you will need to buy the following components.     Part Description  Link  Approximate Cost      TT-01 Clone Chassis  eBay  other TT01s may be used  $130    ESC  https://hobbyking.com/en_us/hobbyking-x-car-45a-brushed-car-esc.html  10.60    Brushed Motor  https://hobbyking.com/en_us/mabuchi-rs-540sh-6527-brushed-motor-90w.html  $5    Steering Servo  https://hobbyking.com/en_us/hobbykingtm-hk15138-standard-analog-servo-4-3kg-0-17sec-38g.html  $5    Battery  https://hobbyking.com/en_us/turnigy-5000mah-2s1p-20c-hardcase-pack-roar-approved-de-warehouse.html or similar 2S 5000 mAh battery  $21    Pinion Gear  https://www.amazon.com/gp/product/B001BHGIBG/ref=oh_aui_detailpage_o08_s00?ie=UTF8 psc=1  $7    TT01 Plastics  Thingiverse: https://www.thingiverse.com/thing:2805287 or Donkeystore: https://squareup.com/store/donkeycar  $50     Note: purchasing from Hobbyking is tricky.  They can ship from multiple warehouses and it can be expensive and time consuming if shipping from one overseas.  You may need to buy an alternate component if one of the items above are not available in your local warehouse.", 
            "title": "Tamaya TT-01 (Advanced Build)"
        }, 
        {
            "location": "/supported_cars/#if-you-want-to-roll-your-own", 
            "text": "It's totally possible to diverge from the main Donkey build, and still have a car that\ndrives well and is fun to work with. We've seen a large variety of cars in the various\nDonkey competitions around the world.  However, when you want to diverge, there are several things you need to know, or you\nwill not be successful. There are many cost and quality trade-offs where the lower\ncost options simply won't work. We've already worked hard to find the cheapest\navailable options that will work, so you should not expect to choose other options to\nsave money. Rolling your own is more about learning, experimentation, and going to new\nand uncharged places.  To find out more about what you need, see  Roll Your Own .", 
            "title": "If You Want to Roll Your Own"
        }, 
        {
            "location": "/roll_your_own/", 
            "text": "Roll Your Own Car\n\n\n\n\nThe Quick and Dirty\n\n\n\n\nYour car needs to be easy to control from a Raspberry Pi\n\n\nYour car needs to be not too large, because it will be too heavy and dangerous (and expensive)\n\n\nYour car needs to be not too small, because it needs to carry a certain minimum amount of equipment\n\n\nYour car needs to meet minimum performance standards in power and control for the model to make sense for it\n\n\nYour car needs to be smooth to control even at low speeds\n\n\n\n\nThis generally means:\n\n\n\n\nYour car needs to have a speed controller for the motor (ESC) that takes a standard RC 3-pin control signal (RC PWM style)\n\n\nYour car needs to have a steering servo that takes a standard RC 3-pin control signal (RC PWM style)\n\n\nYour car needs to have a radio receiver that contains standard 100-mil (2.54 mm) pin headers for each of the ESC and the steering servo.\n\n\nYour car needs to be between 1/18th scale (smallest end) and 1/8th scale (largest end) if you want to race in the DIYRobocars race.\n\n\nYour car needs to either use a brushed motor, or a sensored brushless motor. Sensorless brushless motors are too rough at low speeds.  If you buy a car with a brushless motor included it is invariably a sensorless brushless motor and will need to be replaced along with the ESC.\n\n\n\n\nOther options are perhaps possible, see the end of this document.\n\n\nMany car builders end up looking at \"integrated\" RC hobby cars, because they\nare typically cheaper. However, the reason these are cheaper, is that they will\nintegrate many parts of electronics and mechanics into a single package, which\nmeans that we can't intersect the appropriate signals to control the car with a\nRaspberry Pi. In fact, the expected signals may not even exist at all in an\nintegrated car.\n\n\nHere is an example of an integrated RX and ESC - typically these should be avoided:\n\n\n\nYou also need to know some things about electronics, such as the difference\nbetween power rails and control signals, what the duration of a microsecond is,\nand how Volts, Amperes, Watts, Hours, Ohms, and other measurement units relate.\n\n\nServo Specifics\n\n\nAn RC servo is used for controlling the steering wheels of the car. This servo\ntypically expects around 4.8V to 6V input on the power wire (varies by car) and\na PWM control signal on the signal wire. Typically, the three wires are colored\nblack-red-white, or brown-red-yellow, where the dark wire (black/brown) is ground,\nand the center wire (red) is power, and the light wire (white/yellow) is control.\n\n\nThe control signal is RC-style PWM, where one pulse is sent 60 times a second,\nand the width of this pulse controls how left/right the servo turns. When this\npulse is 1500 microseconds, the servo is centered; when the pulse is 1000\nmicroseconds, the servo is turned all the way left (or right) and when the pulse\nis 2000 microseconds, the servo is turned all the way in the other direction.\nThis is NOT the same kind of PWM that you would use to control the duty cycle of\na motor, or the brightness of a LED.\n\n\nThe power for the servo typically comes from the motor ESC, which has a BEC\n(Battery Eliminator Circuit) built in.\n\n\nESC Specifics\n\n\nThe role of the ESC is to take a RC PWM control signal (pulse between 1000 and\n2000 microseconds) in, and use that to control the power to the motor so the\nmotor spins with different amounts of power in forward or reverse. Again, 1500\nmicroseconds typically means \"center\" which for the motor means \"dead stop.\"\n\n\nThe battery typically connects straight to the ESC using thicker wiring than the\nsimple control signals, because the motor draws many more amps than the control.\nThe ESC then connects on to the motor with equally thick power wiring. The\nstandard Donkey motor and ESC probably have a peak current of about 12A; a\n1/8th scale RC car with powerful brushless motor can have a peak draw up to\n200A!\n\n\nAdditionally, the ESC typically contains a linear or switching voltage converter\nthat outputs the power needed to control the steering servo; this is typically\nsomewhere in the 4.8V to 6V range. Most BECs built into ESCs will not deliver\nmore than about 1A of current, so it is not typically possible to power both the\nsteering servo and the Raspberry Pi from the BEC.\n\n\nReceiver Specifics\n\n\nIf you buy a \"kit car\" that is listed as \"needs a receiver,\" then you don't need\nto buy a receiver. The Raspberry Pi plus the PCA9685 board take the role of the\nreceiver, outputting control signals to the car. Buying a \"kit car\" that comes\nwith steering servo, motor, and ESC, but not with radio, is actually a great way\nto make sure that the car you build will have the right signalling, because any\nRC car with separate receiver will be designed for the appropriate PWM signals.\n\n\nIf your car comes with a receiver, make sure it has the appropriate three-pin\nheaders next to each other for steering servo and for ESC control. Some receivers\nmay have additional three-pin headers for additional channels, which may be empty\nor may control fancy attachments like horns, lights, and so forth.\n\n\nThere is a modification to the Donkey car which uses the RC radio to drive the\ncar when collecting training data; this will give better control of the car than\nyou typically get with a PlayStation controller, or cell phone. However, it also\nrequires replacing the PCA9685 board with an external microcontroller, and\nchanging the software of the Donkey to use it.\n\n\nFinally, some receivers can output, in addition to the PWM control signals, a\nserial data packet that contains the control signals. An example of such a receiver\nis the FS-i6B, which has 6 output channels for PWM signals, but can output 10\nchannels of data at 115,200 bps as serial data, which you can read with an external\nmicrocontroller, or perhaps even with the Raspberry Pi (requries re-configuration\nof the Pi boot loader, and custom modifications to the donkey software.)\n\n\nBatteries\n\n\nThe Donkey comes with a Nickel Metal Hydride battery (NiMH) which is just enough\nto make its motor go, for a little bit of time (5-10 minutes) before needing a\nrecharge. The specifications on this battery are 6 cells, 1100 mAh. Because\nNiHM batteries range from 0.9V to 1.35V with a \"nominal\" voltage of 1.2V, you can\nexpect to see voltages in the 5.4V to 8.1V range.\n\n\nNiHM batteries have medium energy capacity per weight and volume. Thus, you can\nimprove the runtime and performance of the Magnet car by upgrading to a Lithium\nPolymer battery (LiPo.) Typically, you will get a 2 cell battery (2S) and\nLithium batteries have 3.2V to 4.2V per cell, so you will see voltages in the\n6.4V to 8.4V range. Additionally, Lithium Polymer batteries generally have higher\ncurrent capacity (amount of Amps the battery can deliver at one point while\ndriving) as well as energy storage (number of Amp Hours the battery stores when\nfully charged) so it may also last longer.\n\n\nNote that the amount of charge a battery can hold (how long it runs) is measured\nin Ampere-hours, or milli-Ampere-hours, whereas the amount of current a battery\ncan instantaneously deliver while driving is measured simply in Amperes. But to\nmake things more confusing, Amperes are often re-calculated in terms of multiples\nof the energy content, divided by one hour; this ratio is often called \"C.\" Thus,\na LiPo rated for 10C and 2000 mAh, can deliver 20 Amperes of current while\ndriving. A NiHM rated for 5C and 1100 mAh can deliver 5.5 Amperes of current while\ndriving. Batteries typically will deliver more than the C rating for very short\namounts of time, but will heat up or build up internal resistance such that that\nis not something you can rely on for normal operation.\n\n\nFor your custom car, be aware of the voltages needed for the ESC and motor of the\ncar, and make sure to get a battery that matches in voltage. Smaller RC cars will\ncome with NiMH for affordability, or 2S LiPo for power. Larger RC cars will use 3S\n(11.1V) or 4S (14.8V) or even 6S (22.2V) Lithium batteries, and thus need to have\nESC and motor combinations to match.\n\n\nFinally, be sure to get a charger that matches your battery. If you have a LiPo\nbattery, get a good Lithium battery charger, with a balancing plug that matches\nyour battery. Never discharge a Lithium battery below 3.2V per cell; if you let it\nrun dead, it will not want to be charged up to normal voltage again, and trying to\ndo so may very well overheat the batter and light it on fire! See YouTube pictures\nof burning Teslas for what that can look like. Seriously, houses have burned down\nbecause people have tried to save $10 by re-charging a Lithium battery that they\nforgot to disconnect and it ran down too much. It's not worth it. Instead, get a\nbattery alarm, that you plug into the battery balance connector, and it beeps when\nthe battery has discharged so much that you should disconnect and recharge it.\n\n\nPhysical Constraints\n\n\nAdding the additional battery and electronics for self-driving to a toy car will\nadd more load than the car was initially designed for. For a large, 1/8th scale\ncar, this may not be much of a problem. For a small car, 1/18th scale or below, the\nadditional weight and top-heaviness will cause the car to not react well to the\nsteering output, which may cause the self-driving model to be less able to control\nthe car.\n\n\nIf you use a car that's not the standard Magnet, at a minimum, you will have to\nfigure out how to mount all the hardware securely. Just piling things on and hoping\nwiring will keep it in place will not work for things that actually drive and turn.\nFinding good mounting points, and making your own \"base plate\" with measurements\nfrom the car you have, is likely to be necessary. You can build this base plate\nusing 3D printing, laser cutting, CNC milling, or even just drilling into a thin\npiece of plywood, but getting a good fit to your chassis is important, so don't\nrush it or try to cut corners.  \n\n\nDoug LaRue also built a \nconfigurator\n in Thingiverse that enables people to easily make custom 3d printed plates.  \n\n\nOther Options\n\n\nYes, you can make a self-driving car out of your 1/5th scale Nitro Dragster. You\nwill just have to learn even more about the different bits and pieces of the\nsolution, and figure out all the necessary integration yourself. The control\nsignals for a Nitro car are the same, so this might not even be hard. However, the\nindoors arenas used for Donkey Racing Meetups do not allow fuel-burning cars, only\nelectric.\n\n\nYes, you can make a self-driving car out of a cheap two-wheel chassis that uses\na LM298 H-bridge with direct PWM control to \"tank steer\" two wheels. However, you\nwill have to adapt the Donkey software to output the right steering controls, and\nyou will additionally have to figure out how to wire up the H-bridge to the Pi in\na way that makes sense to you; the PWM signals output by the PCA9685 board are the\nRC control kind, NOT the motor control kind! Also, most affordable two-wheel-drive\nrobot chassis are not actually big enough, strong enough, and mechanically\nconsistent enough to make for good Donkey Car candidates.", 
            "title": "Roll Your Own"
        }, 
        {
            "location": "/roll_your_own/#roll-your-own-car", 
            "text": "", 
            "title": "Roll Your Own Car"
        }, 
        {
            "location": "/roll_your_own/#the-quick-and-dirty", 
            "text": "Your car needs to be easy to control from a Raspberry Pi  Your car needs to be not too large, because it will be too heavy and dangerous (and expensive)  Your car needs to be not too small, because it needs to carry a certain minimum amount of equipment  Your car needs to meet minimum performance standards in power and control for the model to make sense for it  Your car needs to be smooth to control even at low speeds   This generally means:   Your car needs to have a speed controller for the motor (ESC) that takes a standard RC 3-pin control signal (RC PWM style)  Your car needs to have a steering servo that takes a standard RC 3-pin control signal (RC PWM style)  Your car needs to have a radio receiver that contains standard 100-mil (2.54 mm) pin headers for each of the ESC and the steering servo.  Your car needs to be between 1/18th scale (smallest end) and 1/8th scale (largest end) if you want to race in the DIYRobocars race.  Your car needs to either use a brushed motor, or a sensored brushless motor. Sensorless brushless motors are too rough at low speeds.  If you buy a car with a brushless motor included it is invariably a sensorless brushless motor and will need to be replaced along with the ESC.   Other options are perhaps possible, see the end of this document.  Many car builders end up looking at \"integrated\" RC hobby cars, because they\nare typically cheaper. However, the reason these are cheaper, is that they will\nintegrate many parts of electronics and mechanics into a single package, which\nmeans that we can't intersect the appropriate signals to control the car with a\nRaspberry Pi. In fact, the expected signals may not even exist at all in an\nintegrated car.  Here is an example of an integrated RX and ESC - typically these should be avoided:  You also need to know some things about electronics, such as the difference\nbetween power rails and control signals, what the duration of a microsecond is,\nand how Volts, Amperes, Watts, Hours, Ohms, and other measurement units relate.", 
            "title": "The Quick and Dirty"
        }, 
        {
            "location": "/roll_your_own/#servo-specifics", 
            "text": "An RC servo is used for controlling the steering wheels of the car. This servo\ntypically expects around 4.8V to 6V input on the power wire (varies by car) and\na PWM control signal on the signal wire. Typically, the three wires are colored\nblack-red-white, or brown-red-yellow, where the dark wire (black/brown) is ground,\nand the center wire (red) is power, and the light wire (white/yellow) is control.  The control signal is RC-style PWM, where one pulse is sent 60 times a second,\nand the width of this pulse controls how left/right the servo turns. When this\npulse is 1500 microseconds, the servo is centered; when the pulse is 1000\nmicroseconds, the servo is turned all the way left (or right) and when the pulse\nis 2000 microseconds, the servo is turned all the way in the other direction.\nThis is NOT the same kind of PWM that you would use to control the duty cycle of\na motor, or the brightness of a LED.  The power for the servo typically comes from the motor ESC, which has a BEC\n(Battery Eliminator Circuit) built in.", 
            "title": "Servo Specifics"
        }, 
        {
            "location": "/roll_your_own/#esc-specifics", 
            "text": "The role of the ESC is to take a RC PWM control signal (pulse between 1000 and\n2000 microseconds) in, and use that to control the power to the motor so the\nmotor spins with different amounts of power in forward or reverse. Again, 1500\nmicroseconds typically means \"center\" which for the motor means \"dead stop.\"  The battery typically connects straight to the ESC using thicker wiring than the\nsimple control signals, because the motor draws many more amps than the control.\nThe ESC then connects on to the motor with equally thick power wiring. The\nstandard Donkey motor and ESC probably have a peak current of about 12A; a\n1/8th scale RC car with powerful brushless motor can have a peak draw up to\n200A!  Additionally, the ESC typically contains a linear or switching voltage converter\nthat outputs the power needed to control the steering servo; this is typically\nsomewhere in the 4.8V to 6V range. Most BECs built into ESCs will not deliver\nmore than about 1A of current, so it is not typically possible to power both the\nsteering servo and the Raspberry Pi from the BEC.", 
            "title": "ESC Specifics"
        }, 
        {
            "location": "/roll_your_own/#receiver-specifics", 
            "text": "If you buy a \"kit car\" that is listed as \"needs a receiver,\" then you don't need\nto buy a receiver. The Raspberry Pi plus the PCA9685 board take the role of the\nreceiver, outputting control signals to the car. Buying a \"kit car\" that comes\nwith steering servo, motor, and ESC, but not with radio, is actually a great way\nto make sure that the car you build will have the right signalling, because any\nRC car with separate receiver will be designed for the appropriate PWM signals.  If your car comes with a receiver, make sure it has the appropriate three-pin\nheaders next to each other for steering servo and for ESC control. Some receivers\nmay have additional three-pin headers for additional channels, which may be empty\nor may control fancy attachments like horns, lights, and so forth.  There is a modification to the Donkey car which uses the RC radio to drive the\ncar when collecting training data; this will give better control of the car than\nyou typically get with a PlayStation controller, or cell phone. However, it also\nrequires replacing the PCA9685 board with an external microcontroller, and\nchanging the software of the Donkey to use it.  Finally, some receivers can output, in addition to the PWM control signals, a\nserial data packet that contains the control signals. An example of such a receiver\nis the FS-i6B, which has 6 output channels for PWM signals, but can output 10\nchannels of data at 115,200 bps as serial data, which you can read with an external\nmicrocontroller, or perhaps even with the Raspberry Pi (requries re-configuration\nof the Pi boot loader, and custom modifications to the donkey software.)", 
            "title": "Receiver Specifics"
        }, 
        {
            "location": "/roll_your_own/#batteries", 
            "text": "The Donkey comes with a Nickel Metal Hydride battery (NiMH) which is just enough\nto make its motor go, for a little bit of time (5-10 minutes) before needing a\nrecharge. The specifications on this battery are 6 cells, 1100 mAh. Because\nNiHM batteries range from 0.9V to 1.35V with a \"nominal\" voltage of 1.2V, you can\nexpect to see voltages in the 5.4V to 8.1V range.  NiHM batteries have medium energy capacity per weight and volume. Thus, you can\nimprove the runtime and performance of the Magnet car by upgrading to a Lithium\nPolymer battery (LiPo.) Typically, you will get a 2 cell battery (2S) and\nLithium batteries have 3.2V to 4.2V per cell, so you will see voltages in the\n6.4V to 8.4V range. Additionally, Lithium Polymer batteries generally have higher\ncurrent capacity (amount of Amps the battery can deliver at one point while\ndriving) as well as energy storage (number of Amp Hours the battery stores when\nfully charged) so it may also last longer.  Note that the amount of charge a battery can hold (how long it runs) is measured\nin Ampere-hours, or milli-Ampere-hours, whereas the amount of current a battery\ncan instantaneously deliver while driving is measured simply in Amperes. But to\nmake things more confusing, Amperes are often re-calculated in terms of multiples\nof the energy content, divided by one hour; this ratio is often called \"C.\" Thus,\na LiPo rated for 10C and 2000 mAh, can deliver 20 Amperes of current while\ndriving. A NiHM rated for 5C and 1100 mAh can deliver 5.5 Amperes of current while\ndriving. Batteries typically will deliver more than the C rating for very short\namounts of time, but will heat up or build up internal resistance such that that\nis not something you can rely on for normal operation.  For your custom car, be aware of the voltages needed for the ESC and motor of the\ncar, and make sure to get a battery that matches in voltage. Smaller RC cars will\ncome with NiMH for affordability, or 2S LiPo for power. Larger RC cars will use 3S\n(11.1V) or 4S (14.8V) or even 6S (22.2V) Lithium batteries, and thus need to have\nESC and motor combinations to match.  Finally, be sure to get a charger that matches your battery. If you have a LiPo\nbattery, get a good Lithium battery charger, with a balancing plug that matches\nyour battery. Never discharge a Lithium battery below 3.2V per cell; if you let it\nrun dead, it will not want to be charged up to normal voltage again, and trying to\ndo so may very well overheat the batter and light it on fire! See YouTube pictures\nof burning Teslas for what that can look like. Seriously, houses have burned down\nbecause people have tried to save $10 by re-charging a Lithium battery that they\nforgot to disconnect and it ran down too much. It's not worth it. Instead, get a\nbattery alarm, that you plug into the battery balance connector, and it beeps when\nthe battery has discharged so much that you should disconnect and recharge it.", 
            "title": "Batteries"
        }, 
        {
            "location": "/roll_your_own/#physical-constraints", 
            "text": "Adding the additional battery and electronics for self-driving to a toy car will\nadd more load than the car was initially designed for. For a large, 1/8th scale\ncar, this may not be much of a problem. For a small car, 1/18th scale or below, the\nadditional weight and top-heaviness will cause the car to not react well to the\nsteering output, which may cause the self-driving model to be less able to control\nthe car.  If you use a car that's not the standard Magnet, at a minimum, you will have to\nfigure out how to mount all the hardware securely. Just piling things on and hoping\nwiring will keep it in place will not work for things that actually drive and turn.\nFinding good mounting points, and making your own \"base plate\" with measurements\nfrom the car you have, is likely to be necessary. You can build this base plate\nusing 3D printing, laser cutting, CNC milling, or even just drilling into a thin\npiece of plywood, but getting a good fit to your chassis is important, so don't\nrush it or try to cut corners.    Doug LaRue also built a  configurator  in Thingiverse that enables people to easily make custom 3d printed plates.", 
            "title": "Physical Constraints"
        }, 
        {
            "location": "/roll_your_own/#other-options", 
            "text": "Yes, you can make a self-driving car out of your 1/5th scale Nitro Dragster. You\nwill just have to learn even more about the different bits and pieces of the\nsolution, and figure out all the necessary integration yourself. The control\nsignals for a Nitro car are the same, so this might not even be hard. However, the\nindoors arenas used for Donkey Racing Meetups do not allow fuel-burning cars, only\nelectric.  Yes, you can make a self-driving car out of a cheap two-wheel chassis that uses\na LM298 H-bridge with direct PWM control to \"tank steer\" two wheels. However, you\nwill have to adapt the Donkey software to output the right steering controls, and\nyou will additionally have to figure out how to wire up the H-bridge to the Pi in\na way that makes sense to you; the PWM signals output by the PCA9685 board are the\nRC control kind, NOT the motor control kind! Also, most affordable two-wheel-drive\nrobot chassis are not actually big enough, strong enough, and mechanically\nconsistent enough to make for good Donkey Car candidates.", 
            "title": "Other Options"
        }, 
        {
            "location": "/contribute/", 
            "text": "Contribute to Donkey\n\n\nDonkey is an open source project to help accelerate the development of \nself driving autos. \n\n\nGuiding Development Principles\n\n\n\n\nModularity\n: A self driving system is composed of standalone, \nindependently configurable components that can be combined to make a car.\n\n\nMinimalism\n: Each component should be kept short (\n100 lines of code). \nEach piece of code should be transparent upon first reading. No black magic, \nit slows the speed of innovation. \n\n\nExtensibility\n: New components should be simple to create by following a \ntemplate. \n\n\nPython\n: Keep it simple. \n\n\n\n\nThese guidelines are nearly copied from \nKeras\n because they are so good\n \n\n\nAdd a part.\n\n\nAre you a hardware specialist that can write a donkey part wrapper for a\nGPS unit or a data scientist that can write an recursive neural net autopilot?\nIf so please write a part so other people driving donkeys can use the part.\n\n\nFix or report a bug.\n\n\nIf you find a problem with the code and you know how to fix it then please\nclone the repo, make your fix, and submit your pull request.\n\n\nReply to issues.\n\n\nHelping close or triage the issues is a good way to help.\n\n\nNeed Inspiration?\n\n\nSearch the code or docs for \nTODO\n to find places where you might be able \nto find a better solution. \n\n\nImprove the documentation.\n\n\nYou can fix grammar or provide clarity by clicking the the \nEdit on GitHub\n \nlink in the top right corner.", 
            "title": "Contribute"
        }, 
        {
            "location": "/contribute/#contribute-to-donkey", 
            "text": "Donkey is an open source project to help accelerate the development of \nself driving autos.", 
            "title": "Contribute to Donkey"
        }, 
        {
            "location": "/contribute/#guiding-development-principles", 
            "text": "Modularity : A self driving system is composed of standalone, \nindependently configurable components that can be combined to make a car.  Minimalism : Each component should be kept short ( 100 lines of code). \nEach piece of code should be transparent upon first reading. No black magic, \nit slows the speed of innovation.   Extensibility : New components should be simple to create by following a \ntemplate.   Python : Keep it simple.    These guidelines are nearly copied from  Keras  because they are so good", 
            "title": "Guiding Development Principles"
        }, 
        {
            "location": "/contribute/#add-a-part", 
            "text": "Are you a hardware specialist that can write a donkey part wrapper for a\nGPS unit or a data scientist that can write an recursive neural net autopilot?\nIf so please write a part so other people driving donkeys can use the part.", 
            "title": "Add a part."
        }, 
        {
            "location": "/contribute/#fix-or-report-a-bug", 
            "text": "If you find a problem with the code and you know how to fix it then please\nclone the repo, make your fix, and submit your pull request.", 
            "title": "Fix or report a bug."
        }, 
        {
            "location": "/contribute/#reply-to-issues", 
            "text": "Helping close or triage the issues is a good way to help.", 
            "title": "Reply to issues."
        }, 
        {
            "location": "/contribute/#need-inspiration", 
            "text": "Search the code or docs for  TODO  to find places where you might be able \nto find a better solution.", 
            "title": "Need Inspiration?"
        }, 
        {
            "location": "/contribute/#improve-the-documentation", 
            "text": "You can fix grammar or provide clarity by clicking the the  Edit on GitHub  \nlink in the top right corner.", 
            "title": "Improve the documentation."
        }, 
        {
            "location": "/tests/", 
            "text": "Tests\n\n\nThere is a limited test suite to ensure that the your changes to the code\ndon't break something unintended. \n\n\nRun all the tests\n\n\npython -m unittest\n\n\nOrganization\n\n\nThe test code is in \ntests\n foders in the same folder as the code. This is to\nhelp keep the test code linked to the code its self. If you change the code, \nchange the tests. :)\n\n\n\n\nTODO: Skip tests that require specific hardware.", 
            "title": "Tests"
        }, 
        {
            "location": "/tests/#tests", 
            "text": "There is a limited test suite to ensure that the your changes to the code\ndon't break something unintended.", 
            "title": "Tests"
        }, 
        {
            "location": "/tests/#run-all-the-tests", 
            "text": "python -m unittest", 
            "title": "Run all the tests"
        }, 
        {
            "location": "/tests/#organization", 
            "text": "The test code is in  tests  foders in the same folder as the code. This is to\nhelp keep the test code linked to the code its self. If you change the code, \nchange the tests. :)   TODO: Skip tests that require specific hardware.", 
            "title": "Organization"
        }, 
        {
            "location": "/release/", 
            "text": "Release notes\n\n\nNotes on how to release donkey.\n\n\nCreate a startup disk.\n\n\n\n\nDownload the previous disk image and create the startup disk.\n\n\nMove disk to you pi. \n\n\nPull the lastest donkeycar code. \n\n\nMake your changes.  \n\n\nMove the disk back to your computer.\n\n\nRemove your wi-fi password and change the host name to d2. Delete \n.gitconfig\n.\n\n\n\n\nCreate the disk image from the SD card\n\n\nRun \nsudo gparted\n to see the size of the disk partitions. Resize the partitions\nto be as small as possible. Right click the partition to see the last sector of the partition. \n\n\nRun \nsudo dd if=/dev/sda of=~/donkey_2-2-1.img bs=512 count=\nlast_sector\n \n\n\n\n\n\n\nZip the .img file and upload to Dropbox. \n\n\n\n\nUpdate the link in the instructions.\n\n\n\n\nCreate a release\n\n\n\n\nRun the tests on computer and pi. \npytest\n\n\nUpdate versions in \n__init__\n and \nsetup.py", 
            "title": "Releases"
        }, 
        {
            "location": "/release/#release-notes", 
            "text": "Notes on how to release donkey.", 
            "title": "Release notes"
        }, 
        {
            "location": "/release/#create-a-startup-disk", 
            "text": "Download the previous disk image and create the startup disk.  Move disk to you pi.   Pull the lastest donkeycar code.   Make your changes.    Move the disk back to your computer.  Remove your wi-fi password and change the host name to d2. Delete  .gitconfig .   Create the disk image from the SD card  Run  sudo gparted  to see the size of the disk partitions. Resize the partitions\nto be as small as possible. Right click the partition to see the last sector of the partition.   Run  sudo dd if=/dev/sda of=~/donkey_2-2-1.img bs=512 count= last_sector      Zip the .img file and upload to Dropbox.    Update the link in the instructions.", 
            "title": "Create a startup disk."
        }, 
        {
            "location": "/release/#create-a-release", 
            "text": "Run the tests on computer and pi.  pytest  Update versions in  __init__  and  setup.py", 
            "title": "Create a release"
        }, 
        {
            "location": "/faq/", 
            "text": "FAQ\n\n\n\n\nWhat types of RC cars work with the donkey platform?\n\n\nMost hobby grade RC cars will work fine with the electronics but you'll need to make your own baseplate and camera\nholder. To make sure the car will work with Donkey check theses things. \n\n\n\n\nit has a separate ESC and reciever. Some of the cheaper cars have these combined so it would require soldering to\nconnect the Donkey motor controller to the ESC.\n\n\nThe ESC uses three-wire connectors. This will make it easy to just plug into the Donkey hardware.\n\n\nBrushed motors are easier because they can go slower but brushless motors can work as well. \n\n\n\n\nFor more information, see \nRoll Your Own\n.\n\n\nWhat car can I use if I'm not in the USA?\n\n\nThe easiest thing to do would be to take your parts down to your local RC / hobby shop and check that the car you want\nworks with the parts. Here are some parts people have said work in other countries. \n\n\n\n\nAustrailia: \nKAOS\n (functionally equivalent to the Exceed Magnet)\n\n\nChina: \nHSP 94186\n (functionally equivalent to the Exceed Magnet)\n\n\nAdd your country to this list (click edit this in top left corner)\n\n\n\n\nHow can I make my own track?\n\n\nYou can use tape, ribbon or even rope. The most popular tracks are 4ft wide and have 2in white borders with a dashed\nyellow center line. The Oakland track is about 70 feet around the center line. Key race characteristics include:\n\n straightaways.\n\n left and right turns\n\n hairpin turn\n\n start/finish line. \n\n\nWill Donkey Work on different hardware?\n\n\nYes. It's all python so you can run it on any system. Usually the hard part of porting Donkey will be getting the hardware working.\nHere are a couple systems that people have tried or talked about.\n\n\n\n\nNVIDA TX2 - This was implemented with a webcam and used a teensy to controll the motor/servos.\n\n\nPi-Zero - Untested but people have gotten OpenCV and Tensorflow installed so it seems possible.\n\n\n\n\nHow do I create my own Raspberry Pi Disk?\n\n\nThis requires an extra 4 hours when command. \n\n\nThis uses minimal space on your memory card, is easy to upgrade and make changes to source\n\n\n\n\nDownload raspian lite\n\n\nOn Windows, \ndownload disk imager\n\n\nOn Mac or Linux, \ndownload Etcher\n\n\nFollow instructions to burn image to memory card.:\n\n\nWin32DiskImager \nvideo\n \n\n\nWin32DiskImager \nwriteup\n\n\nEtcher \nvideo\n\n\nEtcher \nwriteup\n\n\nMultiple methods \nwriteup\n\n\n\n\n\n\n\n\nPlace memory card in Pi and boot\n\n\n\n\n\n\nAfter booting, you will see a prompt. Login. type \npi\n for username.\n\n\n\n\n\n\nType \nraspberry\n for password.\n\n\n\n\n\n\nUse raspi-config to setup some useful options:\n    \nsudo raspi-config\n\n\n\n\nchange hostname\n\n\nchange password\n\n\ninterface options: \n\n\nenable camera\n\n\nenable SSH\n\n\nenable I2C\n\n\n\n\n\n\n\n\n\n\n\n\nReboot.\n\n\n\n\n\n\nDo a package refresh and get latest:\n\n\n\n\n\n\nsudo apt-get update\nsudo apt-get upgrade\n\n\n\n\n\n\nInstall packages:\n\n\n\n\nsudo apt-get install git\nsudo apt-get install python3 python3-pip python3-virtualenv python3-dev virtualenv\nsudo apt-get install build-essential gfortran libhdf5-dev\n\n\n\n\n\n\nGet latest donkey code:\n\n\n\n\ngit clone https://github.com/wroscoe/donkey\ncd donkey\n\n\n\n\n\n\nInstall anaconda:\n\n\n\n\nwget http://repo.continuum.io/miniconda/Miniconda3-latest-Linux-armv7l.sh\nbash Miniconda3-latest-Linux-armv7l.sh\nsource ~/.bashrc\n\n\n\n\n\n\nSetup python environment\n\n\n\n\nconda env create -f envs/rpi.yml\nsource activate donkey\n\n\n\n\n\n\nUpgrade numpy. This can take a long time as it involves compiling the latest.\n\n\n\n\npip install --upgrade numpy\n\n\n\n\n\n\nSetup tensorflow:\n\n\n\n\nwget https://github.com/samjabrahams/tensorflow-on-raspberry-pi/releases/download/v1.1.0/tensorflow-1.1.0-cp34-cp34m-linux_armv7l.whl\npip install tensorflow-1.1.0-cp34-cp34m-linux_armv7l.whl\n\n\n\n\n\n\nSetup donkey\n\n\n\n\npip install -e .\n\n\n\n\n\n\nSetup initial files and dir for data. Refer to \nGet Driving\n for options.\n\n\n\n\n\n\nAfter a reboot, I don't see the (donkey) in front of the prompt, and I get python errors when I run.\n\n\n\n\nIf you used this disc setup guide above, you used conda to manage your virtual environment. You need to activate the donkey conda environment with:\n    \nsource activate donkey\n\n\noptionally you can add that line to the last line of your ~/.bashrc to have it active each time you login.\n\n\n\n\n\n\nHow to get latest Donkey source\n\n\n\n\n\n\nWhen donkey has changed you can get the latest source. You've installed it directly from the github repo, so getting latest is easy:\n     \ncd donkey\n    git pull origin master\n\n\n\n\n\n\nOccasionally also the template files have changed with fixes that affect manage.py. You can create a new user directory to test. Use the same options you used to create it \nfrom setup instructions\n but a new path. For instance:\n    \ndonkey createcar --path ~/d2_new", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#faq", 
            "text": "", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#what-types-of-rc-cars-work-with-the-donkey-platform", 
            "text": "Most hobby grade RC cars will work fine with the electronics but you'll need to make your own baseplate and camera\nholder. To make sure the car will work with Donkey check theses things.    it has a separate ESC and reciever. Some of the cheaper cars have these combined so it would require soldering to\nconnect the Donkey motor controller to the ESC.  The ESC uses three-wire connectors. This will make it easy to just plug into the Donkey hardware.  Brushed motors are easier because they can go slower but brushless motors can work as well.    For more information, see  Roll Your Own .", 
            "title": "What types of RC cars work with the donkey platform?"
        }, 
        {
            "location": "/faq/#what-car-can-i-use-if-im-not-in-the-usa", 
            "text": "The easiest thing to do would be to take your parts down to your local RC / hobby shop and check that the car you want\nworks with the parts. Here are some parts people have said work in other countries.    Austrailia:  KAOS  (functionally equivalent to the Exceed Magnet)  China:  HSP 94186  (functionally equivalent to the Exceed Magnet)  Add your country to this list (click edit this in top left corner)", 
            "title": "What car can I use if I'm not in the USA?"
        }, 
        {
            "location": "/faq/#how-can-i-make-my-own-track", 
            "text": "You can use tape, ribbon or even rope. The most popular tracks are 4ft wide and have 2in white borders with a dashed\nyellow center line. The Oakland track is about 70 feet around the center line. Key race characteristics include:  straightaways.  left and right turns  hairpin turn  start/finish line.", 
            "title": "How can I make my own track?"
        }, 
        {
            "location": "/faq/#will-donkey-work-on-different-hardware", 
            "text": "Yes. It's all python so you can run it on any system. Usually the hard part of porting Donkey will be getting the hardware working.\nHere are a couple systems that people have tried or talked about.   NVIDA TX2 - This was implemented with a webcam and used a teensy to controll the motor/servos.  Pi-Zero - Untested but people have gotten OpenCV and Tensorflow installed so it seems possible.", 
            "title": "Will Donkey Work on different hardware?"
        }, 
        {
            "location": "/faq/#how-do-i-create-my-own-raspberry-pi-disk", 
            "text": "This requires an extra 4 hours when command.", 
            "title": "How do I create my own Raspberry Pi Disk?"
        }, 
        {
            "location": "/faq/#this-uses-minimal-space-on-your-memory-card-is-easy-to-upgrade-and-make-changes-to-source", 
            "text": "Download raspian lite  On Windows,  download disk imager  On Mac or Linux,  download Etcher  Follow instructions to burn image to memory card.:  Win32DiskImager  video    Win32DiskImager  writeup  Etcher  video  Etcher  writeup  Multiple methods  writeup     Place memory card in Pi and boot    After booting, you will see a prompt. Login. type  pi  for username.    Type  raspberry  for password.    Use raspi-config to setup some useful options:\n     sudo raspi-config   change hostname  change password  interface options:   enable camera  enable SSH  enable I2C       Reboot.    Do a package refresh and get latest:    sudo apt-get update\nsudo apt-get upgrade   Install packages:   sudo apt-get install git\nsudo apt-get install python3 python3-pip python3-virtualenv python3-dev virtualenv\nsudo apt-get install build-essential gfortran libhdf5-dev   Get latest donkey code:   git clone https://github.com/wroscoe/donkey\ncd donkey   Install anaconda:   wget http://repo.continuum.io/miniconda/Miniconda3-latest-Linux-armv7l.sh\nbash Miniconda3-latest-Linux-armv7l.sh\nsource ~/.bashrc   Setup python environment   conda env create -f envs/rpi.yml\nsource activate donkey   Upgrade numpy. This can take a long time as it involves compiling the latest.   pip install --upgrade numpy   Setup tensorflow:   wget https://github.com/samjabrahams/tensorflow-on-raspberry-pi/releases/download/v1.1.0/tensorflow-1.1.0-cp34-cp34m-linux_armv7l.whl\npip install tensorflow-1.1.0-cp34-cp34m-linux_armv7l.whl   Setup donkey   pip install -e .   Setup initial files and dir for data. Refer to  Get Driving  for options.", 
            "title": "This uses minimal space on your memory card, is easy to upgrade and make changes to source"
        }, 
        {
            "location": "/faq/#after-a-reboot-i-dont-see-the-donkey-in-front-of-the-prompt-and-i-get-python-errors-when-i-run", 
            "text": "If you used this disc setup guide above, you used conda to manage your virtual environment. You need to activate the donkey conda environment with:\n     source activate donkey  optionally you can add that line to the last line of your ~/.bashrc to have it active each time you login.", 
            "title": "After a reboot, I don't see the (donkey) in front of the prompt, and I get python errors when I run."
        }, 
        {
            "location": "/faq/#how-to-get-latest-donkey-source", 
            "text": "When donkey has changed you can get the latest source. You've installed it directly from the github repo, so getting latest is easy:\n      cd donkey\n    git pull origin master    Occasionally also the template files have changed with fixes that affect manage.py. You can create a new user directory to test. Use the same options you used to create it  from setup instructions  but a new path. For instance:\n     donkey createcar --path ~/d2_new", 
            "title": "How to get latest Donkey source"
        }
    ]
}